<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1, user-scalable=no">
<title>🔟 TenDrop - 10ドロップ（PWA, 1-file）</title>
<meta name="theme-color" content="#fffdf7">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<!-- シンプル1px白PNG（後で差し替え可） -->
<link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAukB9Wj1nZkAAAAASUVORK5CYII=">

<!-- Manifest（内蔵） -->
<script type="application/manifest+json">
{
  "name": "TenDrop - 10ドロップ",
  "short_name": "TenDrop",
  "start_url": ".",
  "display": "standalone",
  "background_color": "#fffdf7",
  "theme_color": "#fffdf7",
  "icons": [
    {"src": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAukB9Wj1nZkAAAAASUVORK5CYII=", "sizes": "192x192", "type":"image/png"}
  ]
}
</script>

<style>
  :root{
    --bg1:#fffdf7; --bg2:#fff3d6; --line:#e9e2d6; --ink:#222; --ink2:#666;
    --chip:#fff; --acc:#00b894; --danger:#ff6b6b;
    --c1:#ff7675; --c2:#fab1a0; --c3:#ffeaa7; --c4:#55efc4; --c5:#81ecec;
    --c6:#74b9ff; --c7:#a29bfe; --c8:#fd79a8; --c9:#fdcb6e;
  }
  html,body{margin:0;height:100%;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--ink);
    font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans JP","Hiragino Sans","Helvetica Neue",Arial,sans-serif;}
  #wrap{display:flex;flex-direction:column;height:100%;}
  header{padding:10px 12px;display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap}
  .row{display:flex;align-items:center;gap:8px}
  .title{font-weight:800;letter-spacing:.02em}
  .btn{border:none;border-radius:12px;padding:8px 12px;background:#111;color:#fff;font-weight:700}
  .btn.ghost{background:#fff;color:#111;border:1px solid var(--line)}
  .chip{background:var(--chip);border:1px solid var(--line);border-radius:12px;padding:8px 10px}
  #stage{flex:1;display:flex;align-items:center;justify-content:center}
  canvas{touch-action:none;background:#fff;border:1px solid var(--line);border-radius:16px;box-shadow:0 6px 30px rgba(0,0,0,.08)}
  footer{padding:8px 12px;display:flex;gap:8px;align-items:center;justify-content:space-between;flex-wrap:wrap}
  .hint{color:var(--ink2)}
  .toast{position:fixed;left:50%;bottom:22px;transform:translateX(-50%);background:#111;color:#fff;border-radius:10px;padding:10px 14px;opacity:0;transition:.25s;pointer-events:none}
  .toast.show{opacity:1}
  #help{position:fixed;inset:0;background:rgba(0,0,0,.4);display:none;align-items:center;justify-content:center;padding:18px}
  #help .card{max-width:520px;background:#fff;border-radius:16px;padding:18px;border:1px solid var(--line);color:#222}
  #help h3{margin:.2em 0 .4em 0}
  #help li{margin:.25em 0}
  .dangerLine{position:absolute;left:50%;transform:translateX(-50%);top:70px;width:min(420px, calc(100% - 32px));height:0;border-top:2px dashed var(--danger);pointer-events:none}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="row">
      <div class="title">🔟 TenDrop - 10ドロップ</div>
      <div id="ver" class="chip">PWA one-file v1</div>
    </div>
    <div class="row">
      <div class="chip">Score: <b id="score">0</b> / Best: <b id="best">0</b></div>
      <div class="chip">Next: <b id="nextNum">-</b>（ペア <b id="pairNum">-</b>）</div>
      <button id="hintBtn" class="btn ghost">ヒント ON</button>
      <button id="helpBtn" class="btn ghost">遊び方</button>
      <button id="resetBtn" class="btn">リセット</button>
    </div>
  </header>

  <div id="stage" style="position:relative">
    <div class="dangerLine"></div>
    <canvas id="cv" width="360" height="640" aria-label="TenDrop game canvas"></canvas>
  </div>

  <footer>
    <div class="hint">列をタップ → 数字の玉を落とす。<b>上下左右で10</b>になったペアは消える。落ちて連鎖で高得点！</div>
  </footer>
</div>

<div id="help">
  <div class="card">
    <h3>🎮 遊び方（10ドロップ）</h3>
    <ol>
      <li>画面の列をタップすると、その列に<strong>数字の玉</strong>が落ちます（1〜9）。</li>
      <li>上下左右で隣り合う数字が<strong>合計10</strong>になると、<b>そのペアは消滅</b>します。</li>
      <li>消えた後は上から落ちて、また10になれば<strong>連鎖</strong>！</li>
      <li><b>Next</b>の右にある「ペア」は10にするための補数（例：Nextが4ならペアは6）。</li>
      <li>上の破線より上まで詰まると<strong>ゲームオーバー</strong>。ベストは端末に保存されます。</li>
    </ol>
    <p class="hint">ヒントONにすると、各マスに「10まであといくつ」が薄く表示され、暗算トレーニングになります。</p>
    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button id="closeHelp" class="btn">OK</button>
    </div>
  </div>
</div>

<div id="toast" class="toast"></div>

<script>
(() => {
  // ===== 基本設定 =====
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const nextNumEl = document.getElementById('nextNum');
  const pairNumEl = document.getElementById('pairNum');
  const resetBtn = document.getElementById('resetBtn');
  const hintBtn = document.getElementById('hintBtn');
  const helpBtn = document.getElementById('helpBtn');
  const helpModal = document.getElementById('help');
  const closeHelp = document.getElementById('closeHelp');
  const toastEl = document.getElementById('toast');

  // 盤面
  const COLS = 6, ROWS = 12; // シンプルに
  const PAD = 16;            // キャンバス左右余白
  const CEIL_Y = 70;         // 危険ライン（px）
  let CELL = Math.floor((cv.width - PAD*2)/COLS);
  const TOP = 90, BOTTOM = cv.height - 16;

  // 状態
  /** @type {(number|null)[][]} */
  let grid;
  let score = 0;
  let next = randNext();
  let showHint = true;
  let over = false;

  // 色（1〜9）
  const COLORS = {
    1:'var(--c1)',2:'var(--c2)',3:'var(--c3)',4:'var(--c4)',5:'var(--c5)',
    6:'var(--c6)',7:'var(--c7)',8:'var(--c8)',9:'var(--c9)'
  };

  // 画面サイズに合わせた表示スケール
  function fit(){
    const w = Math.min(innerWidth - 32, 420);
    const ratio = w / cv.width;
    cv.style.width = w+'px';
    cv.style.height = (cv.height*ratio)+'px';
    CELL = Math.floor((cv.width - PAD*2)/COLS);
  }
  addEventListener('resize', fit); fit();

  // 初期化
  function init(){
    grid = Array.from({length:ROWS}, ()=> Array(COLS).fill(null));
    score = 0; over = false; next = randNext();
    updateHUD(); draw();
  }

  // 次の数字（1〜9）。低い数多め
  function randNext(){
    const r = Math.random();
    if (r<0.15) return 1;
    if (r<0.30) return 2;
    if (r<0.45) return 3;
    if (r<0.60) return 4;
    if (r<0.75) return 5;
    if (r<0.86) return 6;
    if (r<0.93) return 7;
    if (r<0.98) return 8;
    return 9;
  }

  function updateHUD(){
    scoreEl.textContent = score;
    const best = +(localStorage.getItem('tendrop_best')||0);
    if (score>best) localStorage.setItem('tendrop_best', score);
    bestEl.textContent = localStorage.getItem('tendrop_best')||0;
    nextNumEl.textContent = next;
    pairNumEl.textContent = (10-next);
    hintBtn.textContent = showHint? 'ヒント OFF':'ヒント ON';
  }

  // ===== 入力：列タップでドロップ =====
  function canvasColFromEvent(e){
    const rect = cv.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const x = (clientX - rect.left) * (cv.width/rect.width);
    const col = Math.max(0, Math.min(COLS-1, Math.floor((x-PAD)/CELL)));
    return col;
  }

  cv.addEventListener('touchstart', e=>{
    e.preventDefault();
    dropAt(canvasColFromEvent(e));
  }, {passive:false});
  cv.addEventListener('mousedown', e=>{
    dropAt(canvasColFromEvent(e));
  });

  resetBtn.addEventListener('click', init);
  hintBtn.addEventListener('click', ()=>{ showHint = !showHint; updateHUD(); draw(); });
  helpBtn.addEventListener('click', ()=> helpModal.style.display='flex');
  closeHelp.addEventListener('click', ()=> helpModal.style.display='none');

  // ===== ドロップ処理 =====
  function dropAt(col){
    if (over) return;
    // 空き行を探す（下から）
    let r = ROWS-1;
    while(r>=0 && grid[r][col]!==null) r--;
    if (r<0){
      toast('その列はいっぱい！'); return;
    }
    grid[r][col] = next;
    score += next * 2;
    next = randNext();
    updateHUD();
    settle(); // 連鎖処理
  }

  // ===== 連鎖：ペアで10になれば消す（速度条件なし・シンプル） =====
  function settle(){
    let combo = 0;
    while(true){
      const toClear = new Set(); // "r,c" 形式

      // 4近傍で10になるペアを全部マーキング
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const v = grid[r][c];
          if (v===null) continue;
          const need = 10 - v;
          // 右
          if (c+1<COLS && grid[r][c+1]===need){ toClear.add(r+','+c); toClear.add(r+','+(c+1)); }
          // 左
          if (c-1>=0   && grid[r][c-1]===need){ toClear.add(r+','+c); toClear.add(r+','+(c-1)); }
          // 下
          if (r+1<ROWS && grid[r+1][c]===need){ toClear.add(r+','+c); toClear.add((r+1)+','+c); }
          // 上
          if (r-1>=0   && grid[r-1][c]===need){ toClear.add(r+','+c); toClear.add((r-1)+','+c); }
        }
      }

      if (!toClear.size) break; // 連鎖終了

      combo++;
      // 消去＆スコア
      let cleared = 0;
      for(const key of toClear){
        const [rr,cc] = key.split(',').map(Number);
        if (grid[rr][cc]!==null){ cleared++; grid[rr][cc]=null; }
      }
      // 連鎖ボーナス（1連鎖=1.0倍, 2連鎖=1.2倍, 3連鎖=1.4倍…）
      score += Math.floor(cleared * 10 * (1 + (combo-1)*0.2));

      // 重力（列ごとに上から詰める）
      for(let c=0;c<COLS;c++){
        let write = ROWS-1;
        for(let r=ROWS-1;r>=0;r--){
          if (grid[r][c]!==null){
            const v = grid[r][c];
            grid[r][c]=null;
            grid[write][c]=v;
            write--;
          }
        }
      }
    }
    // ゲームオーバー（最上段にブロックが存在し、かつ危険ラインを超える可視領域にある）
    for (let c=0;c<COLS;c++){
      if (grid[0][c]!==null){ over = true; break; }
    }
    if (over) toast('ゲームオーバー！ リセットで再挑戦');
    updateHUD(); draw();
  }

  // ===== 描画 =====
  function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);

    // 枠
    ctx.fillStyle = '#fff';
    ctx.fillRect(0,0,cv.width,cv.height);
    ctx.strokeStyle = getCss('--line'); ctx.lineWidth = 2;
    roundRect(ctx, PAD-8, TOP-8, CELL*COLS+16, (ROWS*CELL)+16, 14); ctx.stroke();

    // 危険表示（内部ガイド）
    ctx.strokeStyle = 'rgba(255,90,90,.35)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(PAD, CEIL_Y); ctx.lineTo(PAD + CELL*COLS, CEIL_Y); ctx.stroke();

    // グリッド背景
    ctx.fillStyle = 'rgba(0,0,0,.02)';
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const x = PAD + c*CELL, y = TOP + r*CELL;
        ctx.fillRect(x+1,y+1, CELL-2, CELL-2);
      }
    }

    // 数字玉
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const v = grid[r][c];
        if (v===null) continue;
        drawBall(c, r, v);
      }
    }

    // ヒント（10まであといくつ）
    if (showHint){
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = '#000';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.font = Math.floor(CELL*0.32)+'px system-ui, -apple-system, sans-serif';
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const x = PAD + c*CELL + CELL/2;
          const y = TOP + r*CELL + CELL/2;
          const v = grid[r][c];
          const t = v===null? '' : (10 - v);
          if (t!=='') ctx.fillText(t, x, y);
        }
      }
      ctx.globalAlpha = 1;
    }
  }

  function drawBall(c, r, v){
    const x = PAD + c*CELL + CELL/2;
    const y = TOP + r*CELL + CELL/2;
    const rad = Math.floor(CELL*0.42);

    // 本体
    const col = getCss('--c'+v);
    const g = ctx.createRadialGradient(x-rad*0.45,y-rad*0.45, rad*0.3, x,y,rad);
    g.addColorStop(0, '#fff'); g.addColorStop(1, col);
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x,y,rad,0,Math.PI*2); ctx.fill();

    // ふち
    ctx.strokeStyle = 'rgba(0,0,0,.08)'; ctx.lineWidth = 2; ctx.stroke();

    // 数字
    ctx.fillStyle = '#1f2937';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font = 'bold '+Math.floor(CELL*0.48)+'px system-ui';
    ctx.fillText(v, x, y+1);
  }

  function roundRect(c,x,y,w,h,r){ c.beginPath(); c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r); c.arcTo(x+w,y+h,x,y+h,r); c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r); c.closePath(); }

  function getCss(varName){
    return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  }

  // ===== ユーティリティ =====
  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    setTimeout(()=>toastEl.classList.remove('show'), 1500);
  }

  // スタート
  init();
})();
</script>

<!-- ===== Service Worker（動的生成：オフラインOK） ===== -->
<script>
if ('serviceWorker' in navigator) {
  const code = `
    const CACHE='tendrop-onefile-v1';
    self.addEventListener('install',e=>{
      e.waitUntil(caches.open(CACHE).then(c=>c.addAll(['./'])));
      self.skipWaiting();
    });
    self.addEventListener('activate',e=>{
      e.waitUntil(caches.keys().then(keys=>Promise.all(keys.map(k=>k!==CACHE&&caches.delete(k)))));
      self.clients.claim();
    });
    self.addEventListener('fetch',e=>{
      e.respondWith(caches.match(e.request).then(r=>r||fetch(e.request)));
    });
  `;
  const blob = new Blob([code], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);
  addEventListener('load', ()=> navigator.serviceWorker.register(url));
}
</script>
</body>
</html>
