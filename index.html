<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<title>10 Baseball — DecaMerge Kids</title>
<meta name="theme-color" content="#F4F1EA">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAukB9Wj1nZkAAAAASUVORK5CYII=">

<!-- Manifest (inline) -->
<script type="application/manifest+json">
{
  "name": "10 Baseball — DecaMerge Kids",
  "short_name": "10 Baseball",
  "start_url": ".",
  "display": "standalone",
  "background_color": "#F4F1EA",
  "theme_color": "#F4F1EA",
  "icons": [
    {"src":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAukB9Wj1nZkAAAAASUVORK5CYII=","sizes":"192x192","type":"image/png"}
  ]
}
</script>

<style>
  :root{
    --bg:#F4F1EA; --paper:#FFFFFF; --ink:#131313; --muted:#6D7280; --line:#E5DED2; --chip:#FBF8F2;
    --accent:#1554F6; --good:#11a36f; --warn:#e24e52;
    --n1:#EB6A5E; --n2:#EE8E5E; --n3:#F0C95E; --n4:#79C5AE; --n5:#A7D5FF;
    --n6:#7CB0F2; --n7:#B6A2E7; --n8:#F28BC4; --n9:#D3A760;
    --b10:#3AB272; --b20:#2A8FBD; --b40:#7A66D9; --b80:#E05C80; --b160:#D48B26; --b320:#3B78D8; --b640:#2F9F66;
  }
  *{box-sizing:border-box}
  html,body{
    height:100%; margin:0; color:var(--ink);
    background:radial-gradient(1200px 600px at 50% -10%,#FFF,#F4F1EA 55%);
    font-family:-apple-system,BlinkMacSystemFont,"SF Pro Display","Helvetica Neue","Segoe UI",Roboto,"Noto Sans JP",Arial,sans-serif;
  }
  #wrap{min-height:100%;display:flex;flex-direction:column}
  header{padding:10px 14px;display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;border-bottom:1px solid var(--line)}
  .brand{display:flex;align-items:baseline;gap:10px}
  .ttl{font-weight:800;letter-spacing:.02em}
  .sub{color:var(--muted);font-size:12px;letter-spacing:.04em}
  .chips{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  .chip{background:var(--chip);border:1px solid var(--line);padding:8px 10px;border-radius:12px}
  .btn{border:1px solid var(--line);padding:8px 12px;border-radius:12px;background:#fff;font-weight:700}
  .btn.strong{border-color:transparent;background:#111;color:#fff}
  .btn.ghost{background:#fff}
  .btn:disabled{opacity:.45}
  .nextBadge{display:flex;align-items:center;gap:8px;background:var(--accent);color:#fff;border-radius:14px;padding:8px 12px;font-weight:800}
  .nextSquare{width:36px;height:36px;border-radius:8px;background:rgba(255,255,255,.22);display:grid;place-items:center;font-size:18px}

  #stage{flex:1;display:flex;align-items:center;justify-content:center;padding:14px}
  canvas{touch-action:none;background:var(--paper);border:1px solid var(--line);border-radius:16px;box-shadow:0 8px 40px rgba(0,0,0,.06)}

  footer{padding:10px 14px;border-top:1px solid var(--line);color:var(--muted);font-size:14px;text-align:center}

  .toast{position:fixed;left:50%;bottom:20px;transform:translateX(-50%);
    background:#111;color:#fff;border-radius:10px;padding:10px 14px;opacity:0;transition:.25s}
  .toast.show{opacity:1}

  /* Help modal */
  #help{position:fixed;inset:0;background:rgba(0,0,0,.38);display:none;align-items:center;justify-content:center;padding:18px}
  #help[open]{display:flex}
  #help .card{width:min(560px,92vw);background:#fff;border:1px solid var(--line);border-radius:16px;padding:16px}
  #help h3{margin:.2em 0 .6em;font-size:18px}
  #help ol{padding-left:1.1em;line-height:1.6}
  #help li{margin:.35em 0}
  #help .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}

  /* ★ 右側のフローティング・スイングボタン */
  #swingBtn{
    position:fixed; right:14px; top:50%; transform:translateY(-50%);
    z-index:9999; width:72px; height:72px; border-radius:999px;
    background:#111; color:#fff; border:none; box-shadow:0 6px 20px rgba(0,0,0,.18);
    font-weight:900; letter-spacing:.06em; font-size:14px;
  }
  #swingBtn:active{transform:translateY(-50%) scale(.98)}
  #swingBtn small{display:block; font-weight:700; opacity:.8; font-size:10px}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="brand">
      <div class="ttl">10 Baseball</div>
      <div class="sub">足して10でパワーアップ！ 合体で点を取ろう</div>
    </div>
    <div class="chips">
      <div class="chip">GameScore: <b id="score">0</b> / Best: <b id="best">0</b></div>
      <div class="chip">Inning: <b id="inning">1</b> / Outs: <b id="outs">0</b> / Runs: <b id="runs">0</b></div>
      <div class="nextBadge">
        Next
        <div class="nextSquare" id="nextA">-</div>
        <div class="nextSquare" id="nextB">-</div>
      </div>
      <button class="btn ghost" id="helpBtn" aria-haspopup="dialog" aria-controls="help">遊び方</button>
      <button class="btn ghost" id="hintBtn">ヒント ON</button>
      <button class="btn ghost" id="undoBtn" disabled>元に戻す</button>
      <button class="btn strong" id="resetBtn">リセット</button>
    </div>
  </header>

  <div id="stage">
    <canvas id="cv" width="360" height="640" aria-label="10 Baseball canvas"></canvas>
  </div>

  <footer>
    ボールは<b>ピッチャー</b>から<b>自動</b>で飛んできます（1.2〜1.8秒間隔）。<br>
    <b>スイング</b>（右の丸ボタン or <b>Space</b>）で<b>中央のホームベース</b>付近を打てます。<br>
    <b>1〜9のボール</b>は<b>合計=10</b>のグループで<b>即「10」</b>に合体（2〜6個）。<b>10,20,40…</b>は<b>同値合体</b>で<b>倍々</b>！<br>
    打球の勢いと角度で<b>ピッチャゴロ/ヒット/2ベース/HR</b>判定。スイング後<b>2秒以内に「10」誕生</b>で<b>学習ボーナス得点</b>！
  </footer>
</div>

<!-- 右側フローティング・スイングボタン -->
<button id="swingBtn" aria-label="スイング">スイング<br><small>Space</small></button>

<!-- How-to -->
<div id="help" role="dialog" aria-modal="true" aria-label="遊び方">
  <div class="card">
    <h3>🎮 遊び方（10 Baseball）</h3>
    <ol>
      <li>ボール（<b>1〜9</b>の<b>丸</b>）が<b>ピッチャー</b>から<b>自動で飛んでき</b>ます。</li>
      <li><b>スイング</b>（右ボタン or <b>Space</b>）で<b>中央固定</b>のバットが弧を描きます。</li>
      <li><b>足し算ミッション：</b>合計が<b>10</b>になる近いボール同士は<b>即合体</b>して<b>10</b>になります。</li>
      <li><b>10,20,40…</b>は<b>同じ数字</b>で触れると<b>倍々合体</b>。</li>
      <li>打球の勢いと角度で<b>ピッチャゴロ/ヒット/ツーベース/ホームラン</b>判定。<b>スイング後2秒以内</b>に<b>10</b>が生まれると<b>学習ボーナス</b>！</li>
      <li>3アウトで回が変わります。点（Runs）をたくさん取ろう！</li>
    </ol>
    <div class="actions">
      <button class="btn ghost" id="closeHelp">閉じる</button>
      <button class="btn strong" id="okHelp">OK</button>
    </div>
  </div>
</div>

<div id="toast" class="toast"></div>

<script>
(()=> {
  // ===== DOM =====
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const nextAEl = document.getElementById('nextA');
  const nextBEl = document.getElementById('nextB');
  const resetBtn = document.getElementById('resetBtn');
  const hintBtn = document.getElementById('hintBtn');
  const undoBtn = document.getElementById('undoBtn');
  const toastEl = document.getElementById('toast');
  const helpBtn = document.getElementById('helpBtn');
  const helpModal = document.getElementById('help');
  const closeHelp = document.getElementById('closeHelp');
  const okHelp = document.getElementById('okHelp');
  const swingBtn = document.getElementById('swingBtn'); // ★ フローティング

  const inningEl = document.getElementById('inning');
  const outsEl   = document.getElementById('outs');
  const runsEl   = document.getElementById('runs');

  // ===== layout fit =====
  function fit(){
    const maxW = Math.min(innerWidth - 24, 440);
    const ratio = maxW / cv.width;
    cv.style.width = maxW+'px';
    cv.style.height = (cv.height*ratio)+'px';
  }
  addEventListener('resize', fit); fit();

  // ===== field & physics =====
  const W = cv.width, H = cv.height;
  const LEFT = 22, RIGHT = W-22, FLOOR = H-14, CEIL = 80; // 赤線
  const BOARD_TOP = 6, BOARD_LEFT = LEFT, BOARD_RIGHT = RIGHT, BOARD_BOTTOM = FLOOR;

  const DT = 1/60, SUBSTEPS = 3;
  const G = 1850;
  const AIR_FRICTION = 0.975;
  const REST_FLOOR = 0.08;
  const REST_WALL  = 0.10;
  const REST_N     = 0.05;
  const VX_MAX = 980, VY_MAX = 2600;
  const MAX_TILES  = 95;
  const ROT_MAX = 0.11;

  // --- Conveyor belts (v>0 →→、v<0 ←←) ---
  const BELTS = [
    { y: 200, t: 12, v: +160 },
    { y: 340, t: 12, v: -160 },
    { y: 480, t: 12, v: +180 },
  ];
  const BREEZE = { amp: 110, speed: 0.7 };

  // ===== baseball state =====
  let inning=1, outs=0, runs=0;
  let bases = { first:false, second:false, third:false };

  function resetBases(){ bases.first=bases.second=bases.third=false; }
  function applyPlay(kind){
    // kind: 'grounder' | 'single' | 'double' | 'homerun'
    if (kind==='grounder'){
      outs++;
      toast('ピッチャゴロ！　アウト');
      if (outs>=3){
        outs=0; inning++; resetBases();
        toast('3アウト交代！ Inning '+inning);
      }
    }else if (kind==='single'){
      // 三->得点, 二->三, 一->二, 打者->一
      if (bases.third) { runs++; bases.third=false; }
      if (bases.second){ bases.third=true; bases.second=false; }
      if (bases.first){ bases.second=true; bases.first=false; }
      bases.first=true;
      toast('ヒット！ 一塁打');
    }else if (kind==='double'){
      // 三/二 -> 得点, 一->三, 打者->二
      if (bases.third){ runs++; bases.third=false; }
      if (bases.second){ runs++; bases.second=false; }
      if (bases.first){ bases.third=true; bases.first=false; }
      bases.second=true;
      toast('ツーベースヒット！');
    }else if (kind==='homerun'){
      let add = 1 + (bases.first?1:0) + (bases.second?1:0) + (bases.third?1:0);
      runs += add;
      resetBases();
      toast('ホームラン！ +'+add+'点');
    }
    updateHUD();
  }

  // ===== game state =====
  /** @type {{x:number,y:number,vx:number,vy:number,h:number,val:number,id:number,m:number,born:number,rot:number}[]} */
  let tiles = [], rings = [];
  let score = 0, over = false, cooldown = 0, gameTime = 0;
  let aimX = (LEFT+RIGHT)/2; // 使わないがゴーストに転用
  let nextQ = [randSmall(), randSmall()];
  let showHint = false;
  let dangerTime = 0;
  let idSeq = 1;

  // 自動ピッチ
  let autoPitchTimer = 1.0;
  const AUTO_MIN=1.2, AUTO_MAX=1.8;

  // スイング→学習ボーナスの猶予
  let swingBonusWindowEnd = 0;
  let bonusGivenThisSwing = false;

  // ジェスチャ（今回は使わないが互換で残す）
  let helpOpen = false;

  // undo
  let undoState = null;

  // ===== helpers =====
  const CSS = (n)=>getComputedStyle(document.documentElement).getPropertyValue(n).trim();
  const colorSmall = (v)=>CSS('--n'+v);
  function colorBig(v){
    if (v>=640) return CSS('--b640');
    if (v>=320) return CSS('--b320');
    if (v>=160) return CSS('--b160');
    if (v>=80)  return CSS('--b80');
    if (v>=40)  return CSS('--b40');
    if (v>=20)  return CSS('--b20');
    return CSS('--b10');
  }

  const L10 = 56, LMAX = 120;
  function halfFor(val){
    const L = Math.min(L10 * Math.sqrt(Math.max(val,1)/10), LMAX);
    return L/2;
  }
  function massFor(h){ const L=2*h; return L*L; }

  function randSmall(){
    const r = Math.random();
    if (r<0.06) return 1;
    if (r<0.14) return 2;
    if (r<0.25) return 3;
    if (r<0.38) return 4;
    if (r<0.53) return 5;
    if (r<0.69) return 6;
    if (r<0.82) return 7;
    if (r<0.93) return 8;
    return 9;
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function updateHUD(){
    scoreEl.textContent = score|0;
    const best = +(localStorage.getItem('decamerge_best_baseball_kids')||0);
    if (score>best) localStorage.setItem('decamerge_best_baseball_kids', score|0);
    bestEl.textContent = localStorage.getItem('decamerge_best_baseball_kids')||0;
    nextAEl.textContent = nextQ[0];
    nextBEl.textContent = nextQ[1];
    hintBtn.textContent = showHint ? 'ヒント OFF' : 'ヒント ON';
    undoBtn.disabled = !undoState;

    inningEl.textContent = inning;
    outsEl.textContent   = outs;
    runsEl.textContent   = runs;
  }

  // ===== modal open/close =====
  function openHelp(){ helpOpen=true; helpModal.setAttribute('open',''); }
  function closeHelpModal(){ helpOpen=false; helpModal.removeAttribute('open'); }
  helpBtn.addEventListener('click', openHelp);
  closeHelp.addEventListener('click', closeHelpModal);
  okHelp.addEventListener('click', closeHelpModal);
  helpModal.addEventListener('click', (e)=>{ if (e.target===helpModal) closeHelpModal(); });
  addEventListener('keydown', (e)=>{ if (e.key==='Escape' && helpOpen) closeHelpModal(); });
  if (!localStorage.getItem('seen_help_baseball_kids')) { openHelp(); localStorage.setItem('seen_help_baseball_kids','1'); }

  resetBtn.addEventListener('click', reset);
  hintBtn.addEventListener('click', ()=>{ showHint = !showHint; updateHUD(); });
  undoBtn.addEventListener('click', undo);

  // ===== game control =====
  function reset(){
    tiles = []; rings = []; score=0; over=false; cooldown=0; dangerTime=0; gameTime=0;
    aimX=(LEFT+RIGHT)/2; nextQ=[randSmall(), randSmall()]; undoState=null;
    inning=1; outs=0; runs=0; resetBases();
    autoPitchTimer = 1.0;
    swingBonusWindowEnd = 0; bonusGivenThisSwing = false;
    updateHUD();
  }
  function snapshot(){
    return { tiles: tiles.map(t=>({x:t.x,y:t.y,vx:t.vx,vy:t.vy,h:t.h,val:t.val,id:t.id,m:t.m,born:t.born,rot:t.rot})),
             rings: rings.map(r=>({...r})),
             score, over, cooldown, dangerTime, aimX, nextQ:[...nextQ], gameTime,
             inning, outs, runs, bases:{...bases}, autoPitchTimer, swingBonusWindowEnd, bonusGivenThisSwing
           };
  }
  function restore(s){
    tiles = s.tiles.map(t=>({...t})); rings = s.rings.map(r=>({...r}));
    score = s.score; over=s.over; cooldown=s.cooldown; dangerTime=s.dangerTime; aimX=s.aimX; nextQ=[...s.nextQ];
    gameTime=s.gameTime;
    inning=s.inning; outs=s.outs; runs=s.runs; bases={...s.bases};
    autoPitchTimer=s.autoPitchTimer; swingBonusWindowEnd=s.swingBonusWindowEnd; bonusGivenThisSwing=s.bonusGivenThisSwing;
    updateHUD();
  }
  function undo(){ if (!undoState) return; restore(undoState); undoState=null; toast('1手戻しました'); }

  // ====== 中央固定バット ======
  const BAT = {
    cx: (LEFT+RIGHT)/2,
    cy: FLOOR - 84,
    r: 18,
    arc: { start:-0.65, end:0.35 },
    swingT: 0,
    DUR: 0.16,
    COOLDOWN: 0.22,
    cd: 0,
    swinging: false,
    didClassifyThisSwing: false,
  };
  function swing(){
    if (BAT.cd>0 || over) return;
    BAT.swingT = BAT.DUR;
    BAT.cd = BAT.COOLDOWN;
    BAT.swinging = true;
    BAT.didClassifyThisSwing = false;
    swingBonusWindowEnd = gameTime + 2.0;
    bonusGivenThisSwing = false;
    toast('スイング！');
  }
  swingBtn.addEventListener('click', swing);
  addEventListener('keydown', (e)=>{ if(e.code==='Space'){ e.preventDefault(); swing(); } });

  function currentBatPos(){
    if (BAT.DUR<=0) return {x:BAT.cx, y:BAT.cy};
    const t = 1 - (BAT.swingT / BAT.DUR);
    const tt = t<0?0:t>1?1:t;
    const k = 1 - Math.pow(1-tt, 2); // ease-out
    const ang = BAT.arc.start + (BAT.arc.end - BAT.arc.start)*k;
    const len = 70;
    const x = BAT.cx + Math.cos(ang)*len;
    const y = BAT.cy + Math.sin(ang)*len;
    return {x,y};
  }

  // ===== 自動ピッチ（投球） =====
  function autoPitch(){
    if (over || cooldown>0) return;
    if (tiles.length>=MAX_TILES){ return; }
    undoState = snapshot();

    const val = nextQ.shift(); nextQ.push(randSmall());
    const h = halfFor(val);
    const x = (LEFT+RIGHT)/2 + (Math.random()*60-30); // ほぼ中央
    const y = CEIL - 28;
    const vx0 = (Math.random()*160-80);               // 少し左右
    const vy0 = 620 + Math.random()*120;              // 速球
    tiles.push({x:clamp(x, LEFT+h+1, RIGHT-h-1), y, vx:vx0, vy:vy0, h, val, id:idSeq++, m:massFor(h), born:gameTime, rot:0});
    score += val; cooldown = .05; updateHUD();
  }

  // ===== 物理補助 =====
  const CONTACT_TOL_SMALL = 7;
  const BIG_MERGE_TOL     = 3;

  function keepInside(t){
    const BOUND_SLOP = 0.5;
    if (t.x - t.h < LEFT+BOUND_SLOP){ t.x = LEFT+BOUND_SLOP + t.h; t.vx = Math.max(t.vx,0)*(-REST_WALL); }
    if (t.x + t.h > RIGHT-BOUND_SLOP){ t.x = RIGHT-BOUND_SLOP - t.h; t.vx = -Math.max(-t.vx,0)*REST_WALL; }
    if (t.y + t.h > FLOOR-BOUND_SLOP){
      t.y = FLOOR-BOUND_SLOP - t.h;
      if (Math.abs(t.vy) < 40) t.vy = 0; else t.vy = -t.vy * REST_FLOOR;
      if (t.vy === 0){ t.vx *= 0.945; if (Math.abs(t.vx)<6) t.vx = 0; }
    }
    if (t.y - t.h < BOARD_TOP+2) { t.y = BOARD_TOP+2 + t.h; t.vy = Math.max(t.vy,0); }
  }

  function resolvePairs(){
    for (let it=0; it<3; it++){
      for (let i=0;i<tiles.length;i++){
        for (let j=i+1;j<tiles.length;j++){
          const A=tiles[i], B=tiles[j];
          const dx=B.x-A.x, dy=B.y-A.y;
          const overlapX = (A.h+B.h) - Math.abs(dx);
          const overlapY = (A.h+B.h) - Math.abs(dy);
          if (overlapX>0 && overlapY>0){
            if (overlapX < overlapY){
              const nx = dx<0 ? -1 : 1;
              const imA = 1/A.m, imB = 1/B.m, inv = imA+imB;
              const pushA=(imA/inv)*overlapX, pushB=(imB/inv)*overlapX;
              A.x -= nx*pushA; B.x += nx*pushB;
              const rvx=B.vx-A.vx, vn=rvx*nx;
              if (vn<0){
                const j = -(1+REST_N)*vn / (imA+imB);
                A.vx -= j*nx*imA; B.vx += j*nx*imB;
              }
            }else{
              const ny = dy<0 ? -1 : 1;
              const imA = 1/A.m, imB = 1/B.m, inv = imA+imB;
              const pushA=(imA/inv)*overlapY, pushB=(imB/inv)*overlapY;
              A.y -= ny*pushA; B.y += ny*pushB;
              const rvy=B.vy-A.vy, vn=rvy*ny;
              if (vn<0){
                const j = -(1+REST_N)*vn / (imA+imB);
                A.vy -= j*ny*imA; B.vy += j*ny*imB;
              }
            }
          }
        }
      }
      for (const t of tiles) keepInside(t);
    }
  }
  function relaxWorld(n=4){ for(let i=0;i<n;i++) resolvePairs(); }

  // ===== 当たり判定（バット）と打球判定 =====
  function classifyPlayFrom(vx, vy){
    const V = Math.hypot(vx, vy);
    const angleRad = Math.atan2(-vy, vx); // 上向きが正
    const deg = angleRad * 180/Math.PI;

    // しきい値：低速→ゴロ／中速低角→単打／中〜高速中角→二塁打／高速高角→HR
    if (V >= 1100 && deg >= 35) return 'homerun';
    if (V >= 800  && deg >= 15) return 'double';
    if (V >= 500  && deg >= -5) return 'single';
    return 'grounder';
  }

  function tryBatHits(){
    if (BAT.swingT<=0) return;
    const pos = currentBatPos();
    let hitOccurred = false;

    for (const t of tiles){
      // 円 x 正方形
      const clx = clamp(pos.x, t.x - t.h, t.x + t.h);
      const cly = clamp(pos.y, t.y - t.h, t.y + t.h);
      const dx = pos.x - clx, dy = pos.y - cly;
      if (dx*dx + dy*dy <= BAT.r*BAT.r){
        // 法線方向へ押し出す
        let nx = (t.x - pos.x), ny = (t.y - pos.y);
        const nlen = Math.hypot(nx, ny) || 1;
        nx /= nlen; ny /= nlen;

        const base = 560;
        const massBias = 1 / Math.sqrt(Math.max(t.m, 1600)) / 0.025;
        const J = base * massBias;

        t.vx += nx * J;
        t.vy += ny * J * 0.9;

        rings.push({x:t.x, y:t.y, t:0, col:'#FF7F50'});
        score += 5 + Math.min(20, Math.floor((Math.abs(t.vx)+Math.abs(t.vy))/60));
        updateHUD();

        // 最初のヒットで打球種別を確定
        if (!BAT.didClassifyThisSwing){
          const kind = classifyPlayFrom(t.vx, t.vy);
          applyPlay(kind);
          BAT.didClassifyThisSwing = true;
        }
        hitOccurred = true;
      }
    }

    if (hitOccurred) {
      // 連打し過ぎ防止（実質1回の判定になる）
      BAT.swingT = Math.max(0, BAT.swingT - 0.04);
    }
  }

  // ===== 合体（足して10 / 同値倍々） =====
  function touchingSmall(a,b){
    const dx=Math.abs(b.x-a.x), dy=Math.abs(b.y-a.y);
    return dx <= (a.h + b.h + CONTACT_TOL_SMALL) && dy <= (a.h + b.h + CONTACT_TOL_SMALL);
  }
  function contactBig(a,b){
    const overlapX = (a.h+b.h) - Math.abs(b.x-a.x);
    const overlapY = (a.h+b.h) - Math.abs(b.y-a.y);
    return (overlapX >= 0 && overlapY >= -BIG_MERGE_TOL) ||
           (overlapY >= 0 && overlapX >= -BIG_MERGE_TOL) ||
           (overlapX >= 0 && overlapY >= 0);
  }

  function tryMerges(){
    let changed=false;
    let tenMadeThisTick = 0;

    // 大タイル
    const removedBig = new Set();
    for (let i=0;i<tiles.length;i++){
      const A=tiles[i]; if (A.val<10 || removedBig.has(A.id)) continue;
      for (let j=i+1;j<tiles.length;j++){
        const B=tiles[j]; if (B.val<10 || removedBig.has(B.id)) continue;
        if (A.val===B.val && contactBig(A,B)){
          const out=A.val*2, nx=(A.x+B.x)/2, ny=(A.y+B.y)/2;
          const h=halfFor(out), vx=(A.vx+B.vx)*0.1, vy=(A.vy+B.vy)*0.1;
          tiles.push({x:nx,y:ny,vx,vy,h,val:out,id:idSeq++, m:massFor(h), born:gameTime, rot:(A.rot+B.rot)/2});
          removedBig.add(A.id); removedBig.add(B.id);
          rings.push({x:nx,y:ny,t:0,col:colorBig(out)});
          score += Math.max(30,out);
          changed = true;
        }
      }
    }
    if (removedBig.size){ tiles = tiles.filter(t=>!removedBig.has(t.id)); updateHUD(); }

    // 小タイル：合計=10
    const small = tiles.filter(t=>t.val<10);
    if (small.length){
      const adj = small.map(()=>[]);
      for (let i=0;i<small.length;i++)
        for (let j=i+1;j<small.length;j++)
          if (touchingSmall(small[i], small[j])){ adj[i].push(j); adj[j].push(i); }

      const visited = new Array(small.length).fill(false);
      const toRemove = new Set(); const toAdd = [];

      for (let s=0;s<small.length;s++){
        if (visited[s]) continue;
        // 成分
        const comp=[]; const q=[s]; visited[s]=true;
        while(q.length){ const v=q.shift(); comp.push(v); for (const nb of adj[v]) if(!visited[nb]){visited[nb]=true;q.push(nb);} }
        if (comp.length<2) continue;

        let avail = comp.slice();
        const chosenSets = [];
        function findK(sorted,k){
          const arr=sorted, n=arr.length; let res=null;
          function dfs(st, need, sum, ps){
            if (sum>10) return false;
            if (need===0){ if (sum===10){ res=ps; return true; } return false; }
            for (let i=st;i<n;i++){
              const idx=arr[i], v=small[idx].val;
              if (sum+v>10) continue;
              if (dfs(i+1, need-1, sum+v, [...ps, idx])) return true;
            }
            return false;
          }
          return dfs(0,k,0,[]) ? res : null;
        }

        while(true){
          let picked=null;
          const sorted = [...avail].sort((ia,ib)=>small[ib].val-small[ia].val);
          for (const k of [2,3,4,5,6]){ if (avail.length>=k){ const res=findK(sorted,k); if (res){ picked=res; break; } } }
          if (picked){
            chosenSets.push(picked);
            const setPicked = new Set(picked);
            avail = avail.filter(i=>!setPicked.has(i));
          }else break;
        }

        for (const picked of chosenSets){
          const chosen = picked.map(i=>small[i]);
          const cx = chosen.reduce((a,b)=>a+b.x,0)/chosen.length;
          const cy = chosen.reduce((a,b)=>a+b.y,0)/chosen.length;
          const cvx= chosen.reduce((a,b)=>a+b.vx,0)/chosen.length * 0.1;
          const cvy= chosen.reduce((a,b)=>a+b.vy,0)/chosen.length * 0.1;
          const h  = halfFor(10);
          toAdd.push({x:cx,y:cy,vx:cvx,vy:cvy,h,val:10,id:idSeq++, m:massFor(h), born:gameTime, rot:0});
          chosen.forEach(b=>toRemove.add(b.id));
          rings.push({x:cx,y:cy,t:0,col:colorBig(10)});
          score += 16 + 2*chosen.length;
          tenMadeThisTick++;
          changed = true;
        }
      }

      if (toRemove.size){
        tiles = tiles.filter(t=>!toRemove.has(t.id));
        tiles.push(...toAdd);
        updateHUD();
      }
    }

    // 学習ボーナス（スイング後2秒以内に10が生まれたら1点）
    if (tenMadeThisTick>0 && gameTime <= swingBonusWindowEnd && !bonusGivenThisSwing){
      runs += 1;
      bonusGivenThisSwing = true;
      toast('🎓 10ができた！ 学習ボーナス +1点');
      updateHUD();
    }

    return changed;
  }

  // ===== 1フレーム =====
  function step(dt){
    gameTime += dt;
    cooldown = Math.max(0, cooldown-dt);

    // 自動ピッチ
    if (!over){
      autoPitchTimer -= dt;
      if (autoPitchTimer<=0){
        autoPitch();
        autoPitchTimer = AUTO_MIN + Math.random()*(AUTO_MAX-AUTO_MIN);
      }
    }

    // スイング時間＆CD
    if (BAT.swingT>0) {
      BAT.swingT = Math.max(0, BAT.swingT - dt);
    } else {
      BAT.swinging = false;
    }
    if (BAT.cd>0) BAT.cd = Math.max(0, BAT.cd - dt);

    const breeze = BREEZE.amp * Math.sin(gameTime*BREEZE.speed);

    // integrate
    for (const t of tiles){
      t.vy += G*dt;

      // ベルト
      const bottom = t.y + t.h;
      for (const b of BELTS){
        if (bottom > b.y - b.t && bottom < b.y + b.t){
          t.vx += b.v * dt * 0.9;
          t.vx *= 0.992;
        }
      }
      // 風
      t.vx += breeze * dt * 0.12;

      // 減衰と制限
      t.vx *= AIR_FRICTION; t.vy *= AIR_FRICTION;
      t.vx = clamp(t.vx, -VX_MAX, VX_MAX);
      t.vy = clamp(t.vy, -VY_MAX, VY_MAX);

      t.x += t.vx*dt; t.y += t.vy*dt;

      keepInside(t);

      // 見た目の傾き（丸にも少し効かせる）
      const target = clamp(t.vx/620, -ROT_MAX, ROT_MAX);
      t.rot += (target - t.rot) * 0.12;
    }

    resolvePairs();

    // 合体
    let changed, pass=0; do{ changed = tryMerges(); pass++; } while(changed && pass<16);
    if (changed) relaxWorld(4);

    // バット当たり
    tryBatHits();

    // fx
    for (const r of rings){ r.t += dt; }
    rings = rings.filter(r=>r.t<0.9);

    // ゲームオーバー（赤線）
    const AGE_SAFE = 0.45, MARGIN = 1;
    let danger=false;
    for (const t of tiles){
      if (gameTime - t.born < AGE_SAFE) continue;
      if (t.y - t.h <= CEIL - MARGIN){ danger=true; break; }
    }
    dangerTime = danger ? Math.min(10, dangerTime+dt) : 0;
    if (dangerTime > 0.70 && !over){ over=true; toast('GAME OVER! 元に戻す or リセット'); }
  }

  // ===== 描画 =====
  function drawBall(x,y,h,val,rot){
    // 野球ボール風（白丸＋赤い縫い目）
    const R = h;
    ctx.save(); ctx.translate(x,y); ctx.rotate(rot||0);
    // 本体
    const g = ctx.createRadialGradient(-R*0.4,-R*0.6, R*0.2, 0,0, R);
    g.addColorStop(0,'#fff'); g.addColorStop(1,'#e9e9e9');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='rgba(0,0,0,.08)'; ctx.lineWidth=2; ctx.stroke();

    // 縫い目
    ctx.strokeStyle='#d33'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(0,0,R*0.72, -1.1, 1.1); ctx.stroke();
    ctx.beginPath(); ctx.arc(0,0,R*0.72, Math.PI-1.1, Math.PI+1.1); ctx.stroke();
    // ステッチ
    function stitches(a0,a1){
      const n=6;
      for(let i=0;i<=n;i++){
        const t=i/n, ang=a0+(a1-a0)*t;
        const px=Math.cos(ang)*R*0.72, py=Math.sin(ang)*R*0.72;
        const nx=-Math.sin(ang), ny=Math.cos(ang);
        ctx.beginPath();
        ctx.moveTo(px-nx*4, py-ny*4); ctx.lineTo(px+nx*4, py+ny*4);
        ctx.stroke();
      }
    }
    stitches(-1.1,1.1); stitches(Math.PI-1.1, Math.PI+1.1);

    // 数字
    ctx.fillStyle='#111'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font = 'bold '+Math.floor(h*1.15)+'px system-ui'; ctx.fillText(val, 0, 2);

    // ヒント：10- val
    if (showHint){
      ctx.fillStyle='rgba(0,0,0,.42)'; ctx.font=Math.floor(h*0.6)+'px system-ui';
      ctx.fillText(10-val, 0, -h*1.2);
    }
    ctx.restore();
  }

  function drawSquare(x,y,h,val,rot){
    const L = 2*h, r = Math.min(12, h*0.45);
    const base = colorBig(val);
    ctx.save(); ctx.translate(x,y); ctx.rotate(rot||0);
    const g = ctx.createLinearGradient(-h, -h, h, h);
    g.addColorStop(0,'#fff'); g.addColorStop(1, base);
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.roundRect(-h, -h, L, L, r); ctx.fill();
    ctx.strokeStyle='rgba(0,0,0,.08)'; ctx.lineWidth=2; ctx.stroke();
    ctx.fillStyle='#111'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font = 'bold '+Math.floor(h*1.1)+'px system-ui'; ctx.fillText(val, 0, 1);
    ctx.restore();
  }

  function drawTile(x,y,h,val,rot){
    if (val<10) drawBall(x,y,h,val,rot);
    else drawSquare(x,y,h,val,rot);
  }

  function drawBelt(y, t, dir){
    ctx.fillStyle = 'rgba(234,229,218,0.55)';
    ctx.fillRect(LEFT+1, y-t, RIGHT-LEFT-2, t*2);
    ctx.save(); ctx.translate(0, y);
    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    for (let x=LEFT+10; x<RIGHT-10; x+=30){
      ctx.beginPath();
      if (dir>0){ ctx.moveTo(x-6, -4); ctx.lineTo(x+6, 0); ctx.lineTo(x-6, 4); }
      else      { ctx.moveTo(x+6, -4); ctx.lineTo(x-6, 0); ctx.lineTo(x+6, 4); }
      ctx.closePath(); ctx.fill();
    }
    ctx.restore();
  }

  function drawDiamondHUD(){
    // 画面左上にダイヤモンド表示
    const x = 32, y = 26, a = 9;
    function base(px,py,filled){
      ctx.save(); ctx.translate(px,py); ctx.rotate(Math.PI/4);
      ctx.fillStyle = filled ? 'rgba(17,163,111,0.9)' : 'rgba(0,0,0,0.08)';
      ctx.strokeStyle='rgba(0,0,0,0.18)'; ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.rect(-a,-a,a*2,a*2); ctx.fill(); ctx.stroke();
      ctx.restore();
    }
    base(x, y, bases.second);
    base(x-18, y+18, bases.first);
    base(x+18, y+18, bases.third);
    // ホームベース（中央固定の目安）
    ctx.save(); ctx.translate(x, y+36); ctx.rotate(Math.PI/4);
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.beginPath(); ctx.rect(-a,-a,a*2,a*2); ctx.fill();
    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    // 外枠
    ctx.strokeStyle = CSS('--line'); ctx.lineWidth = 2;
    roundRectPath(LEFT-8, 6, RIGHT-LEFT+16, FLOOR-6, 16); ctx.stroke();

    // 盤面内クリップ
    ctx.save(); ctx.beginPath();
    ctx.rect(BOARD_LEFT, BOARD_TOP, BOARD_RIGHT-BOARD_LEFT, BOARD_BOTTOM-BOARD_TOP);
    ctx.clip();

    // コンベア帯
    for (const b of BELTS) drawBelt(b.y, b.t, b.v>0?1:-1);

    // 赤線
    ctx.strokeStyle = 'rgba(226,78,82,.65)';
    ctx.setLineDash([6,4]); ctx.beginPath(); ctx.moveTo(LEFT, CEIL); ctx.lineTo(RIGHT, CEIL); ctx.stroke(); ctx.setLineDash([]);

    // ゴースト（次の球の目安）
    const hN = halfFor(nextQ[0]);
    const ax = (LEFT+RIGHT)/2;
    ctx.globalAlpha=.22; drawBall(ax, CEIL-28, hN, nextQ[0], 0); ctx.globalAlpha=1;

    // タイル
    for (const t of tiles) drawTile(t.x,t.y,t.h,t.val,t.rot);

    // 合体リング
    for (const rr of rings){
      ctx.globalAlpha = Math.max(0, 1 - rr.t*1.1);
      ctx.strokeStyle = rr.col; ctx.lineWidth = 3;
      const r = 8 + rr.t*42;
      ctx.beginPath(); ctx.roundRect(rr.x - r, rr.y - r, r*2, r*2, 10); ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.restore();

    // バット（中央固定）
    {
      const a0 = BAT.arc.start, a1 = BAT.arc.end, R = 70;
      // ガイド弧
      ctx.strokeStyle = 'rgba(0,0,0,.08)'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(BAT.cx, BAT.cy, R, a0, a1); ctx.stroke();
      // ヘッド円
      const bp = currentBatPos();
      ctx.globalAlpha = (BAT.swingT>0) ? 0.95 : 0.5;
      ctx.fillStyle = 'rgba(20,20,20,.20)';
      ctx.beginPath(); ctx.arc(bp.x, bp.y, BAT.r, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
      // 「ねらい：10-?」ヒント（次の球の補助）
      if (showHint){
        ctx.fillStyle='rgba(0,0,0,.55)'; ctx.textAlign='center'; ctx.textBaseline='top';
        ctx.font='bold 14px system-ui';
        ctx.fillText('ねらい：'+(10 - nextQ[0]), BAT.cx, BAT.cy + R + 8);
      }
    }

    // ベースHUD
    drawDiamondHUD();

    if (over){
      ctx.fillStyle = 'rgba(0,0,0,.48)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.font='bold 32px system-ui'; ctx.fillText('GAME OVER', W/2, H*0.42);
      ctx.font='16px system-ui'; ctx.fillText('「元に戻す」または「リセット」', W/2, H*0.58);
    }
  }

  function roundRectPath(x,y,w,h,r){
    ctx.beginPath(); ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
  }

  // ===== メインループ =====
  function toast(msg){ toastEl.textContent=msg; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'), 1300); }
  let acc=0, last=performance.now();
  function loop(now){
    const dt = (now-last)/1000; last=now; acc += dt;
    const DT = 1/60, SUBSTEPS = 3;
    while(acc>DT){
      const sdt = DT/SUBSTEPS;
      for (let k=0;k<SUBSTEPS;k++) step(sdt);
      acc -= DT;
    }
    draw(); requestAnimationFrame(loop);
  }
  reset(); updateHUD(); requestAnimationFrame(loop);
})();
</script>

<!-- Service Worker（オフライン対応・動的生成） -->
<script>
if ('serviceWorker' in navigator) {
  const code = `
    const CACHE='10baseball-decamerge-kids-v1';
    self.addEventListener('install',e=>{
      e.waitUntil(caches.open(CACHE).then(c=>c.addAll(['./'])));
      self.skipWaiting();
    });
    self.addEventListener('activate',e=>{
      e.waitUntil(caches.keys().then(keys=>Promise.all(keys.map(k=>k!==CACHE&&caches.delete(k)))));
      self.clients.claim();
    });
    self.addEventListener('fetch',e=>{
      e.respondWith(caches.match(e.request).then(r=>r||fetch(e.request)));
    });
  `;
  const blob = new Blob([code], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);
  addEventListener('load', () => navigator.serviceWorker.register(url));
}
</script>
</body>
</html>
