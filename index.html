<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<title>10 Game â€” DecaMerge (Squares + Ops) v3.4</title>
<meta name="theme-color" content="#F4F1EA">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAukB9Wj1nZkAAAAASUVORK5CYII=">

<!-- Manifest (inline) -->
<script type="application/manifest+json">
{
  "name": "10 Game â€” DecaMerge (Squares + Ops)",
  "short_name": "10 Game",
  "start_url": ".",
  "display": "standalone",
  "background_color": "#F4F1EA",
  "theme_color": "#F4F1EA",
  "icons": [
    {"src":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAukB9Wj1nZkAAAAASUVORK5CYII=","sizes":"192x192","type":"image/png"}
  ]
}
</script>

<style>
  :root{
    --bg:#F4F1EA; --paper:#FFFFFF; --ink:#131313; --muted:#6D7280; --line:#E5DED2; --chip:#FBF8F2;
    --accent:#1554F6;
    --n1:#EB6A5E; --n2:#EE8E5E; --n3:#F0C95E; --n4:#79C5AE; --n5:#A7D5FF;
    --n6:#7CB0F2; --n7:#B6A2E7; --n8:#F28BC4; --n9:#D3A760;
    --b10:#3AB272; --b20:#2A8FBD; --b40:#7A66D9; --b80:#E05C80; --b160:#D48B26; --b320:#3B78D8; --b640:#2F9F66;
    --tok:#111; --tokFg:#fff;
  }
  *{box-sizing:border-box}
  html,body{
    height:100%; margin:0; color:var(--ink);
    background:radial-gradient(1200px 600px at 50% -10%,#FFF,#F4F1EA 55%);
    font-family:-apple-system,BlinkMacSystemFont,"SF Pro Display","Helvetica Neue","Segoe UI",Roboto,"Noto Sans JP",Arial,sans-serif;
  }
  #wrap{min-height:100%;display:flex;flex-direction:column}
  header{padding:10px 14px;display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;border-bottom:1px solid var(--line)}
  .brand{display:flex;align-items:baseline;gap:10px}
  .ttl{font-weight:800;letter-spacing:.02em}
  .sub{color:var(--muted);font-size:12px;letter-spacing:.04em}
  .chips{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  .chip{background:var(--chip);border:1px solid var(--line);padding:8px 10px;border-radius:12px}
  .btn{border:1px solid var(--line);padding:8px 12px;border-radius:12px;background:#fff;font-weight:700}
  .btn.strong{border-color:transparent;background:#111;color:#fff}
  .btn.ghost{background:#fff}
  .btn:disabled{opacity:.45}
  .nextBadge{display:flex;align-items:center;gap:8px;background:var(--accent);color:#fff;border-radius:14px;padding:8px 12px;font-weight:800}
  .nextSquare{width:36px;height:36px;border-radius:8px;background:rgba(255,255,255,.22);display:grid;place-items:center;font-size:18px}

  #stage{flex:1;display:flex;align-items:center;justify-content:center;padding:14px}
  canvas{touch-action:none;background:var(--paper);border:1px solid var(--line);border-radius:16px;box-shadow:0 8px 40px rgba(0,0,0,.06)}

  footer{padding:10px 14px;border-top:1px solid var(--line);color:var(--muted);font-size:14px;text-align:center}

  .toast{position:fixed;left:50%;bottom:20px;transform:translateX(-50%);
    background:#111;color:#fff;border-radius:10px;padding:10px 14px;opacity:0;transition:.25s}
  .toast.show{opacity:1}

  /* Help modal */
  #help{position:fixed;inset:0;background:rgba(0,0,0,.38);display:none;align-items:center;justify-content:center;padding:18px}
  #help[open]{display:flex}
  #help .card{width:min(560px,92vw);background:#fff;border:1px solid var(--line);border-radius:16px;padding:16px}
  #help h3{margin:.2em 0 .6em;font-size:18px}
  #help ol{padding-left:1.1em;line-height:1.6}
  #help li{margin:.35em 0}
  #help .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="brand">
      <div class="ttl">10 Game</div>
      <div class="sub">DecaMerge â€” è¶³ã—ã¦10 â†’ 10â†’20â†’40â€¦ï¼ˆå››è§’ï¼‹æ¼”ç®—ï¼‰</div>
    </div>
    <div class="chips">
      <div class="chip">Score: <b id="score">0</b> / Best: <b id="best">0</b></div>
      <div class="nextBadge">
        Next
        <div class="nextSquare" id="nextA">-</div>
        <div class="nextSquare" id="nextB">-</div>
      </div>
      <button class="btn ghost" id="helpBtn" aria-haspopup="dialog" aria-controls="help">éŠã³æ–¹</button>
      <button class="btn ghost" id="hintBtn">ãƒ’ãƒ³ãƒˆ ON</button>
      <button class="btn ghost" id="undoBtn" disabled>å…ƒã«æˆ»ã™</button>
      <button class="btn strong" id="resetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
    </div>
  </header>

  <div id="stage">
    <canvas id="cv" width="360" height="640" aria-label="10 Game canvas"></canvas>
  </div>

  <footer>
    æŒ‡ã§<strong>å·¦å³ã«ã‚¹ãƒ©ã‚¤ãƒ‰</strong>â†’<strong>æŒ‡ã‚’é›¢ã™</strong>ã¨æŠ•å…¥ã€‚<br>
    å°ã‚¿ã‚¤ãƒ«ã¯<strong>åˆè¨ˆ=10</strong>ã§åˆä½“ï¼ˆ2ã€œ6å€‹ï¼‰ã€‚ã•ã‚‰ã«<strong>2Ã—5=10</strong>ãƒšã‚¢ã€<strong>âˆ’/Ã·ãƒˆãƒ¼ã‚¯ãƒ³</strong>ã§å­¦ã³ï¼†ã‚³ãƒ³ãƒœï¼
  </footer>
</div>

<!-- How-to -->
<div id="help" role="dialog" aria-modal="true" aria-label="éŠã³æ–¹">
  <div class="card">
    <h3>ğŸ® éŠã³æ–¹ï¼ˆ10 Game - DecaMerge / Squares + Opsï¼‰</h3>
    <ol>
      <li>ç”»é¢ä¸Šã§æŒ‡ã‚’<strong>å·¦å³ã«ã‚¹ãƒ©ã‚¤ãƒ‰</strong>ã—ã¦ç‹™ã„ã‚’åˆã‚ã›ã€<strong>æŒ‡ã‚’é›¢ã™</strong>ã¨æŠ•å…¥ã€‚</li>
      <li><strong>1ã€œ9ã®å°ã‚¿ã‚¤ãƒ«</strong>ï¼šéš£ã‚Šåˆã†ã‚°ãƒ«ãƒ¼ãƒ—ã§<strong>åˆè¨ˆ=10</strong>ãªã‚‰<strong>å³ã€Œ10ã€</strong>ã«åˆä½“ï¼ˆ2ã€œ6å€‹ã€è¤‡æ•°åŒæ™‚OKï¼‰ã€‚</li>
      <li><strong>ã‹ã‘ç®—</strong>ï¼š<b>2 ã¨ 5</b>ãŒéš£ã‚Šåˆã†ã¨<strong>10</strong>ã«åˆä½“ã€‚</li>
      <li><strong>ã²ãç®—ï¼ˆâˆ’ãƒˆãƒ¼ã‚¯ãƒ³ï¼‰</strong>ï¼šå°ã‚¿ã‚¤ãƒ«ã«è§¦ã‚Œã‚‹ã¨ãã®å€¤ã‚’<strong>10âˆ’x</strong>ã«å¤‰æ›ï¼ˆè£œæ•°ï¼‰ã€‚</li>
      <li><strong>ã‚ã‚Šç®—ï¼ˆÃ·ãƒˆãƒ¼ã‚¯ãƒ³ï¼‰</strong>ï¼š<b>10,20,40â€¦</b>ã«è§¦ã‚Œã‚‹ã¨åŠåˆ†ã«åˆ†å‰²ï¼ˆ10â†’5+5ã€20â†’10+10â€¦ï¼‰ã€‚</li>
      <li><strong>åŒã˜å¤§ã‚¿ã‚¤ãƒ«</strong>ã¯è»½ãé‡ãªã£ãŸã‚‰<strong>å€ã€…åˆä½“</strong>ã€‚èµ¤ç·šã‚ˆã‚Šä¸Šã«ä¸€å®šæ™‚é–“ã‚ã‚‹ã¨<b>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</b>ã€‚</li>
    </ol>
    <p style="color:var(--muted);font-size:13px">ãƒ’ãƒ³ãƒˆONã§å„å°ã‚¿ã‚¤ãƒ«ã«ã€Œ10ã¾ã§ã‚ã¨ã„ãã¤ã€ã‚’è¡¨ç¤ºã€‚</p>
    <div class="actions">
      <button class="btn ghost" id="closeHelp">é–‰ã˜ã‚‹</button>
      <button class="btn strong" id="okHelp">OK</button>
    </div>
  </div>
</div>

<div id="toast" class="toast"></div>

<script>
(()=> {
  // ===== DOM =====
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const nextAEl = document.getElementById('nextA');
  const nextBEl = document.getElementById('nextB');
  const resetBtn = document.getElementById('resetBtn');
  const hintBtn = document.getElementById('hintBtn');
  const undoBtn = document.getElementById('undoBtn');
  const toastEl = document.getElementById('toast');
  const helpBtn = document.getElementById('helpBtn');
  const helpModal = document.getElementById('help');
  const closeHelp = document.getElementById('closeHelp');
  const okHelp = document.getElementById('okHelp');

  // ===== layout fit =====
  function fit(){
    const maxW = Math.min(innerWidth - 24, 440);
    const ratio = maxW / cv.width;
    cv.style.width = maxW+'px';
    cv.style.height = (cv.height*ratio)+'px';
  }
  addEventListener('resize', fit); fit();

  // ===== constants (field & physics) =====
  const W = cv.width, H = cv.height;
  const LEFT = 22, RIGHT = W-22, FLOOR = H-14, CEIL = 80; // èµ¤ç·š
  const DT = 1/60;
  const G = 1850;                 // é‡åŠ›å¼·ã‚ï¼ˆç©ã¿ä¸ŠãŒã‚Šã‚„ã™ãï¼‰
  const AIR_FRICTION = 0.975;     // æ¸›è¡°å¼·ã‚
  const REST_FLOOR = 0.08;        // ä½åç™º
  const REST_WALL  = 0.10;
  const REST_N     = 0.05;        // ã‚¿ã‚¤ãƒ«åŒå£«ã®åç™ºï¼ˆå°ï¼‰
  const VX_MAX = 980, VY_MAX = 2600;
  const MAX_TILES  = 95;

  // ===== game state =====
  /** @type {{type:'num'|'token',tokenType?:'minus'|'divide',x:number,y:number,vx:number,vy:number,h:number,val:number,id:number,m:number,born:number}[]} */
  let tiles = [], rings = [];
  let score = 0, over = false, cooldown = 0, gameTime = 0;
  let aimX = (LEFT+RIGHT)/2;
  let nextQ = [randSpawn(), randSpawn()];
  let showHint = true;
  let dangerTime = 0;
  let idSeq = 1;

  // gesture / modal
  let helpOpen = false, dragging = false, activePointer=null;

  // undo
  let undoState = null;

  // ===== helpers =====
  const CSS = (n)=>getComputedStyle(document.documentElement).getPropertyValue(n).trim();
  const colorSmall = (v)=>CSS('--n'+v);
  function colorBig(v){
    if (v>=640) return CSS('--b640');
    if (v>=320) return CSS('--b320');
    if (v>=160) return CSS('--b160');
    if (v>=80)  return CSS('--b80');
    if (v>=40)  return CSS('--b40');
    if (v>=20)  return CSS('--b20');
    return CSS('--b10');
  }

  // === é¢ç©æ¯”ï¼ˆå››è§’ï¼‰ï¼šè¾ºé•· L = L10 * âˆš(value/10) / ã“ã“ã§ã¯åŠè¾º h ã‚’è¿”ã™ ===
  const L10 = 56, LMAX = 120; // 10ã®è¾ºé•· / ä¸Šé™
  function halfFor(val){
    const L = Math.min(L10 * Math.sqrt(Math.max(val,1)/10), LMAX);
    return L/2;
  }
  function massFor(h){ const L=2*h; return L*L; } // é¢ç©ï¼è³ªé‡

  // ç”Ÿæˆï¼šæ•°ã‚¿ã‚¤ãƒ«ä¸­å¿ƒ + ä½ç¢ºç‡ã§ãƒˆãƒ¼ã‚¯ãƒ³
  function randSmall(){
    const r = Math.random();
    if (r<0.06) return 1;
    if (r<0.14) return 2;
    if (r<0.25) return 3;
    if (r<0.38) return 4;
    if (r<0.53) return 5;
    if (r<0.69) return 6;
    if (r<0.82) return 7;
    if (r<0.93) return 8;
    return 9;
  }
  function randSpawn(){
    const t = Math.random();
    if (t < 0.06) return { type:'token', tokenType:'divide' }; // 6%
    if (t < 0.14) return { type:'token', tokenType:'minus'  }; // 8%
    return { type:'num', val: randSmall() };
  }
  function toLabel(sp){
    if (sp.type==='token') return sp.tokenType==='minus' ? 'âˆ’' : 'Ã·';
    return ''+sp.val;
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function updateHUD(){
    scoreEl.textContent = score|0;
    const best = +(localStorage.getItem('decamerge_best_sq_ops')||0);
    if (score>best) localStorage.setItem('decamerge_best_sq_ops', score|0);
    bestEl.textContent = localStorage.getItem('decamerge_best_sq_ops')||0;
    nextAEl.textContent = toLabel(nextQ[0]);
    nextBEl.textContent = toLabel(nextQ[1]);
    hintBtn.textContent = showHint ? 'ãƒ’ãƒ³ãƒˆ OFF' : 'ãƒ’ãƒ³ãƒˆ ON';
    undoBtn.disabled = !undoState;
  }

  // ===== modal open/close =====
  function resetPointerState(){
    try { if (activePointer!==null) cv.releasePointerCapture(activePointer); } catch(e){}
    dragging=false; activePointer=null;
  }
  function openHelp(){ helpOpen=true; helpModal.setAttribute('open',''); resetPointerState(); }
  function closeHelpModal(){ helpOpen=false; helpModal.removeAttribute('open'); resetPointerState(); }
  helpBtn.addEventListener('click', openHelp);
  closeHelp.addEventListener('click', closeHelpModal);
  okHelp.addEventListener('click', closeHelpModal);
  helpModal.addEventListener('click', (e)=>{ if (e.target===helpModal) closeHelpModal(); });
  addEventListener('keydown', (e)=>{ if (e.key==='Escape' && helpOpen) closeHelpModal(); });
  if (!localStorage.getItem('decamerge_seen_help_sqops')) { openHelp(); localStorage.setItem('decamerge_seen_help_sqops','1'); }

  // ===== pointer inputs =====
  function canvasX(e){
    const rect = cv.getBoundingClientRect();
    const clientX = e.clientX ?? (e.touches && e.touches[0].clientX) ?? rect.left;
    return (clientX - rect.left) * (cv.width/rect.width);
  }
  function onPointerDown(e){
    if (helpOpen) return;
    if (activePointer !== null) return;
    cv.setPointerCapture(e.pointerId);
    activePointer = e.pointerId;
    dragging = true;
    aimX = clamp(canvasX(e), LEFT, RIGHT);
  }
  function onPointerMove(e){
    if (!dragging || e.pointerId !== activePointer) return;
    aimX = clamp(canvasX(e), LEFT, RIGHT);
  }
  function onPointerUp(e){
    if (e.pointerId !== activePointer) return;
    if (!helpOpen) drop(); // æŒ‡ã‚’é›¢ã—ãŸã‚‰è½ã¨ã™
    resetPointerState();
  }
  if (window.PointerEvent){
    cv.addEventListener('pointerdown', onPointerDown, {passive:false});
    cv.addEventListener('pointermove', onPointerMove, {passive:false});
    cv.addEventListener('pointerup',   onPointerUp,   {passive:false});
    cv.addEventListener('pointercancel', ()=> resetPointerState(), {passive:true});
  }

  resetBtn.addEventListener('click', reset);
  hintBtn.addEventListener('click', ()=>{ showHint = !showHint; updateHUD(); });
  undoBtn.addEventListener('click', undo);

  // ===== game control =====
  function reset(){
    tiles = []; rings = []; score=0; over=false; cooldown=0; dangerTime=0; gameTime=0;
    aimX=(LEFT+RIGHT)/2; nextQ=[randSpawn(), randSpawn()]; undoState=null;
    updateHUD();
  }
  function snapshot(){
    return { tiles: tiles.map(t=>({type:t.type,tokenType:t.tokenType,x:t.x,y:t.y,vx:t.vx,vy:t.vy,h:t.h,val:t.val,id:t.id,m:t.m,born:t.born})),
             rings: rings.map(r=>({...r})),
             score, over, cooldown, dangerTime, aimX, nextQ:JSON.parse(JSON.stringify(nextQ)), gameTime };
  }
  function restore(s){
    tiles = s.tiles.map(t=>({...t}));
    rings = s.rings.map(r=>({...r}));
    score = s.score; over=s.over; cooldown=s.cooldown; dangerTime=s.dangerTime; aimX=s.aimX; nextQ=JSON.parse(JSON.stringify(s.nextQ));
    gameTime=s.gameTime; updateHUD();
  }
  function undo(){ if (!undoState) return; restore(undoState); undoState=null; toast('1æ‰‹æˆ»ã—ã¾ã—ãŸ'); }
  function drop(){
    if (over || cooldown>0) return;
    if (tiles.length>=MAX_TILES){ toast('ã„ã£ã±ã„ã§ã™ã€‚åˆä½“ã§æ¸›ã‚‰ãã†ï¼'); return; }
    undoState = snapshot();
    const spawn = nextQ.shift(); nextQ.push(randSpawn());
    let obj;
    if (spawn.type==='token'){
      const h = 16; // å°ã•ã‚
      const x = clamp(aimX, LEFT+h+1, RIGHT-h-1);
      obj = {type:'token', tokenType:spawn.tokenType, x, y:CEIL-30, vx:0, vy:0, h, val:0, id:idSeq++, m:massFor(h), born:gameTime};
    }else{
      const val = spawn.val;
      const h = halfFor(val);
      const x = clamp(aimX, LEFT+h+1, RIGHT-h-1);
      obj = {type:'num', x, y:CEIL-30, vx:0, vy:0, h, val, id:idSeq++, m:massFor(h), born:gameTime};
      score += val;
    }
    tiles.push(obj);
    cooldown = .18; updateHUD();
  }

  // ===== physics (AABB squares) =====
  function step(dt){
    gameTime += dt;
    cooldown = Math.max(0, cooldown-dt);

    for (const t of tiles){
      t.vy += G*dt;
      t.vx *= AIR_FRICTION; t.vy *= AIR_FRICTION;
      t.vx = clamp(t.vx, -VX_MAX, VX_MAX);
      t.vy = clamp(t.vy, -VY_MAX, VY_MAX);
      t.x  += t.vx*dt;  t.y  += t.vy*dt;

      // Walls
      if (t.x - t.h < LEFT){ t.x = LEFT + t.h; t.vx = -Math.abs(t.vx)*REST_WALL; }
      if (t.x + t.h > RIGHT){ t.x = RIGHT - t.h; t.vx =  Math.abs(t.vx)*(-REST_WALL); }

      // Floor
      if (t.y + t.h > FLOOR){
        t.y = FLOOR - t.h;
        if (Math.abs(t.vy) < 40) t.vy = 0; else t.vy = -t.vy * REST_FLOOR;
        if (t.vy === 0){ t.vx *= 0.945; if (Math.abs(t.vx)<6) t.vx = 0; }
      }
    }

    // Tile-tile collisions (mass-based resolution)
    for (let i=0;i<tiles.length;i++){
      for (let j=i+1;j<tiles.length;j++){
        const A=tiles[i], B=tiles[j];
        const dx=B.x-A.x, dy=B.y-A.y;
        const overlapX = (A.h+B.h) - Math.abs(dx);
        const overlapY = (A.h+B.h) - Math.abs(dy);
        if (overlapX>0 && overlapY>0){
          if (overlapX < overlapY){
            const nx = dx<0 ? -1 : 1;
            const imA = 1/A.m, imB = 1/B.m, inv=imA+imB;
            const pushA = (imA/inv)*overlapX, pushB = (imB/inv)*overlapX;
            A.x -= nx*pushA; B.x += nx*pushB;
            const rvx = B.vx - A.vx, vn = rvx*nx;
            if (vn<0){
              const j = -(1+REST_N)*vn / (imA+imB);
              A.vx -= j*nx*imA; B.vx += j*nx*imB;
            }
          }else{
            const ny = dy<0 ? -1 : 1;
            const imA = 1/A.m, imB = 1/B.m, inv=imA+imB;
            const pushA = (imA/inv)*overlapY, pushB = (imB/inv)*overlapY;
            A.y -= ny*pushA; B.y += ny*pushB;
            const rvy = B.vy - A.vy, vn = rvy*ny;
            if (vn<0){
              const j = -(1+REST_N)*vn / (imA+imB);
              A.vy -= j*ny*imA; B.vy += j*ny*imB;
            }
          }
        }
      }
    }

    // ãƒˆãƒ¼ã‚¯ãƒ³æŒ™å‹•ï¼ˆâˆ’ã§è£œæ•°åŒ–ã€Ã·ã§åˆ†å‰²ï¼‰
    tokenActions();

    // åˆä½“ï¼ˆè¤‡æ•°ãƒ‘ã‚¹ã§åæŸï¼‰
    let changed, pass=0;
    do{ changed = tryMerges(); pass++; } while(changed && pass<16);

    // FX
    for (const r of rings){ r.t += dt; }
    rings = rings.filter(r=>r.t<0.9);

    // === èµ¤ç·šã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼ˆä½ç½®ã®ã¿ï¼å¹´é½¢ã‚²ãƒ¼ãƒˆï¼‰ ===
    const AGE_SAFE = 0.45, MARGIN = 1;
    let danger=false;
    for (const t of tiles){
      if (gameTime - t.born < AGE_SAFE) continue;
      const top = t.y - t.h;
      if (top <= CEIL - MARGIN){ danger=true; break; }
    }
    dangerTime = danger ? Math.min(10, dangerTime+dt) : 0;
    if (dangerTime > 0.70 && !over){ over=true; toast('GAME OVER! å…ƒã«æˆ»ã™ or ãƒªã‚»ãƒƒãƒˆ'); }
  }

  // ===== token interactions =====
  function tokenActions(){
    const toRemove = new Set();
    for (const tok of tiles){
      if (tok.type!=='token') continue;

      if (tok.tokenType==='minus'){
        // è¿‘ã„å°ã‚¿ã‚¤ãƒ«ï¼ˆ1..9ï¼‰ã‚’æ¢ã—ã€é‡ãªã‚Šé–¾å€¤ã§è£œæ•°åŒ–
        let target=null, bestD=1e9;
        for (const t of tiles){
          if (t.type!=='num' || t.val>=10) continue;
          const dx=Math.abs(t.x - tok.x), dy=Math.abs(t.y - tok.y);
          const tol = 2 + Math.min(t.h, tok.h)*0.6;
          if (dx <= t.h+tok.h && dy <= t.h+tok.h){
            const d = dx+dy;
            if (d<bestD){ bestD=d; target=t; }
          }else if (dx<=t.h+tok.h+tol && dy<=t.h+tok.h+tol){
            const d = dx+dy+5;
            if (d<bestD){ bestD=d; target=t; }
          }
        }
        if (target){
          const before = target.val;
          target.val = Math.max(1, 10 - target.val); // 10âˆ’xï¼ˆ1..9ã«åã¾ã‚‹ï¼‰
          target.h = halfFor(target.val); target.m = massFor(target.h);
          rings.push({x:target.x,y:target.y,t:0,col:'#111'}); // é»’ãƒªãƒ³ã‚°ã§æ¼”å‡º
          score += 5; // å°ãƒœãƒ¼ãƒŠã‚¹
          toRemove.add(tok.id);
        }
      }else if (tok.tokenType==='divide'){
        // å¤§ã‚¿ã‚¤ãƒ«ï¼ˆ>=10 ã‹ã¤å¶æ•°*5ï¼‰ã«è§¦ã‚ŒãŸã‚‰åŠåˆ†ã«åˆ†å‰²
        let target=null;
        for (const t of tiles){
          if (t.type!=='num' || t.val<10) continue;
          const overlapX = (t.h+tok.h) - Math.abs(t.x-tok.x);
          const overlapY = (t.h+tok.h) - Math.abs(t.y-tok.y);
          if (overlapX>0 && overlapY>0){ target=t; break; }
        }
        if (target){
          const v = target.val;
          if (v % 20 === 0 || v===10 || v===20 || v===40 || v===80 || v===160 || v===320 || v===640){
            const half = v/2;
            const h = halfFor(half);
            const offs = Math.max(6, h*0.2);
            tiles.push({type:'num', x:target.x-offs, y:target.y, vx:target.vx-20, vy:target.vy, h, val:half, id:idSeq++, m:massFor(h), born:gameTime});
            tiles.push({type:'num', x:target.x+offs, y:target.y, vx:target.vx+20, vy:target.vy, h, val:half, id:idSeq++, m:massFor(h), born:gameTime});
            rings.push({x:target.x,y:target.y,t:0,col:'#111'});
            score += 5;
            // remove target & token
            tiles = tiles.filter(t=>t.id!==target.id);
            toRemove.add(tok.id);
          }
        }
      }
    }
    if (toRemove.size) tiles = tiles.filter(t=>!toRemove.has(t.id));
  }

  // ===== merging rules =====
  const CONTACT_TOL_SMALL = 7;  // å°ã‚¿ã‚¤ãƒ«ã®éš£æ¥è¨±å®¹
  const BIG_OVERLAP_PIX   = 1;  // å¤§ã‚¿ã‚¤ãƒ«é‡ãªã‚Šé–¾å€¤

  function touchingSmall(a,b){
    const dx=Math.abs(b.x-a.x), dy=Math.abs(b.y-a.y);
    return dx <= (a.h + b.h + CONTACT_TOL_SMALL) && dy <= (a.h + b.h + CONTACT_TOL_SMALL);
  }
  function overlappingBig(a,b){
    const overlapX = (a.h+b.h) - Math.abs(b.x-a.x);
    const overlapY = (a.h+b.h) - Math.abs(b.y-a.y);
    return overlapX > BIG_OVERLAP_PIX && overlapY > BIG_OVERLAP_PIX;
  }

  function tryMerges(){
    let changed=false;

    // --- å¤§ã‚¿ã‚¤ãƒ«ï¼šåŒå€¤ãŒè»½ãé‡ãªã£ãŸã‚‰å€åŒ– ---
    const removedBig = new Set();
    for (let i=0;i<tiles.length;i++){
      const A=tiles[i]; if (A.type!=='num' || A.val<10 || removedBig.has(A.id)) continue;
      for (let j=i+1;j<tiles.length;j++){
        const B=tiles[j]; if (B.type!=='num' || B.val<10 || removedBig.has(B.id)) continue;
        if (A.val===B.val && overlappingBig(A,B)){
          const out=A.val*2, nx=(A.x+B.x)/2, ny=(A.y+B.y)/2;
          const h=halfFor(out), vx=(A.vx+B.vx)*0.1, vy=(A.vy+B.vy)*0.1;
          tiles.push({type:'num', x:nx,y:ny,vx,vy,h,val:out,id:idSeq++, m:massFor(h), born:gameTime});
          removedBig.add(A.id); removedBig.add(B.id);
          rings.push({x:nx,y:ny,t:0,col:colorBig(out)});
          score += Math.max(30,out);
          changed = true;
        }
      }
    }
    if (removedBig.size){ tiles = tiles.filter(t=>!removedBig.has(t.id)); updateHUD(); }

    // --- å°ã‚¿ã‚¤ãƒ«ï¼š2Ã—5=10 ã®ç‰¹åˆ¥ãƒ«ãƒ¼ãƒ«ï¼ˆÃ—ï¼‰ ---
    const small = tiles.filter(t=>t.type==='num' && t.val<10);
    const toRemoveMul = new Set(); const toAddMul=[];
    for (let i=0;i<small.length;i++){
      for (let j=i+1;j<small.length;j++){
        const A=small[i], B=small[j];
        if (toRemoveMul.has(A.id) || toRemoveMul.has(B.id)) continue;
        if (A.val*B.val===10 && touchingSmall(A,B)){
          const cx=(A.x+B.x)/2, cy=(A.y+B.y)/2, h=halfFor(10);
          const vx=(A.vx+B.vx)*0.1, vy=(A.vy+B.vy)*0.1;
          toAddMul.push({type:'num', x:cx,y:cy,vx,vy,h,val:10,id:idSeq++, m:massFor(h), born:gameTime});
          toRemoveMul.add(A.id); toRemoveMul.add(B.id);
          rings.push({x:cx,y:cy,t:0,col:colorBig(10)});
          score += 8; // Ã—ãƒœãƒ¼ãƒŠã‚¹
          changed = true;
        }
      }
    }
    if (toRemoveMul.size){
      tiles = tiles.filter(t=>!toRemoveMul.has(t.id));
      tiles.push(...toAddMul);
      updateHUD();
    }

    // --- å°ã‚¿ã‚¤ãƒ«ï¼šåˆè¨ˆ=10ï¼ˆ2ã€œ6å€‹ã€åŒãƒ•ãƒ¬ãƒ¼ãƒ è¤‡æ•°ï¼‰ ---
    if (small.length){
      const adj = small.map(()=>[]);
      for (let i=0;i<small.length;i++)
        for (let j=i+1;j<small.length;j++)
          if (touchingSmall(small[i], small[j])){ adj[i].push(j); adj[j].push(i); }

      const visited = new Array(small.length).fill(false);
      const toRemove = new Set(); const toAdd = [];

      for (let s=0;s<small.length;s++){
        if (visited[s]) continue;
        // æˆåˆ†æŠ½å‡º
        const comp=[]; const q=[s]; visited[s]=true;
        while(q.length){ const v=q.shift(); comp.push(v); for (const nb of adj[v]) if(!visited[nb]){visited[nb]=true;q.push(nb);} }
        if (comp.length<2) continue;

        let avail = comp.slice();
        const chosenSets = [];

        while(true){
          let picked=null;
          const sorted = [...avail].sort((ia,ib)=>small[ib].val-small[ia].val);

          function findK(k){
            const arr=sorted, n=arr.length; let res=null;
            function dfs(st, need, sum, ps){
              if (sum>10) return false;
              if (need===0){ if (sum===10){ res=ps; return true; } return false; }
              for (let i=st;i<n;i++){
                const idx=arr[i], v=small[idx].val;
                if (sum+v>10) continue;
                if (dfs(i+1, need-1, sum+v, [...ps, idx])) return true;
              }
              return false;
            }
            return dfs(0,k,0,[]) ? res : null;
          }

          for (const k of [2,3,4,5,6]){ if (avail.length>=k){ const res=findK(k); if (res){ picked=res; break; } } }

          if (picked){
            chosenSets.push(picked);
            const setPicked = new Set(picked);
            avail = avail.filter(i=>!setPicked.has(i));
          }else{
            break;
          }
        }

        for (const picked of chosenSets){
          const chosen = picked.map(i=>small[i]);
          const cx = chosen.reduce((a,b)=>a+b.x,0)/chosen.length;
          const cy = chosen.reduce((a,b)=>a+b.y,0)/chosen.length;
          const cvx= chosen.reduce((a,b)=>a+b.vx,0)/chosen.length * 0.1;
          const cvy= chosen.reduce((a,b)=>a+b.vy,0)/chosen.length * 0.1;
          const h  = halfFor(10);
          toAdd.push({type:'num', x:cx,y:cy,vx:cvx,vy:cvy,h,val:10,id:idSeq++, m:massFor(h), born:gameTime});
          chosen.forEach(b=>toRemove.add(b.id));
          rings.push({x:cx,y:cy,t:0,col:colorBig(10)});
          score += 16 + 2*chosen.length;
          changed = true;
        }
      }

      if (toRemove.size){
        tiles = tiles.filter(t=>!toRemove.has(t.id));
        tiles.push(...toAdd);
        updateHUD();
      }
    }

    return changed;
  }

  // ===== render =====
  function draw(){
    ctx.clearRect(0,0,W,H);
    // frame
    ctx.strokeStyle = CSS('--line'); ctx.lineWidth = 2;
    roundRectPath(LEFT-8, 6, RIGHT-LEFT+16, FLOOR-6, 16); ctx.stroke();
    // red line
    ctx.strokeStyle = 'rgba(226,78,82,.65)';
    ctx.setLineDash([6,4]); ctx.beginPath(); ctx.moveTo(LEFT, CEIL); ctx.lineTo(RIGHT, CEIL); ctx.stroke(); ctx.setLineDash([]);

    // ghost (next)
    const gsp = nextQ[0];
    if (gsp.type==='token'){
      const hN = 16;
      const ax = clamp(aimX, LEFT+hN+1, RIGHT-hN-1);
      ctx.globalAlpha=.28; drawToken(ax, CEIL-28, hN, gsp.tokenType); ctx.globalAlpha=1;
    }else{
      const hN = halfFor(gsp.val);
      const ax = clamp(aimX, LEFT+hN+1, RIGHT-hN-1);
      ctx.globalAlpha=.28; drawTile(ax, CEIL-28, hN, gsp.val); ctx.globalAlpha=1;
    }

    // tiles
    for (const t of tiles){
      if (t.type==='token') drawToken(t.x,t.y,t.h,t.tokenType);
      else drawTile(t.x,t.y,t.h,t.val);
    }

    // rings
    for (const rr of rings){
      ctx.globalAlpha = Math.max(0, 1 - rr.t*1.1);
      ctx.strokeStyle = rr.col; ctx.lineWidth = 3;
      const r = 8 + rr.t*42;
      ctx.beginPath(); ctx.roundRect(rr.x - r, rr.y - r, r*2, r*2, 10); ctx.stroke();
      ctx.globalAlpha = 1;
    }

    if (over){
      ctx.fillStyle = 'rgba(0,0,0,.48)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.font='bold 32px system-ui'; ctx.fillText('GAME OVER', W/2, H*0.42);
      ctx.font='16px system-ui'; ctx.fillText('ã€Œå…ƒã«æˆ»ã™ã€ã¾ãŸã¯ã€Œãƒªã‚»ãƒƒãƒˆã€', W/2, H*0.58);
    }
  }

  function drawTile(x,y,h,val){
    const L = 2*h, r = Math.min(12, h*0.45);
    const base = val<10 ? colorSmall(val) : colorBig(val);
    const g = ctx.createLinearGradient(x-h, y-h, x+h, y+h);
    g.addColorStop(0,'#fff'); g.addColorStop(1, base);
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.roundRect(x-h, y-h, L, L, r); ctx.fill();
    ctx.strokeStyle='rgba(0,0,0,.08)'; ctx.lineWidth=2; ctx.stroke();

    ctx.fillStyle='#111'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font = 'bold '+Math.floor(h*1.2)+'px system-ui'; ctx.fillText(val, x, y+1);
    if (showHint && val<10){
      ctx.fillStyle='rgba(0,0,0,.35)'; ctx.font=Math.floor(h*0.6)+'px system-ui';
      ctx.fillText(10-val, x, y - h*1.1);
    }
  }

  function drawToken(x,y,h,kind){
    const L=2*h, r=Math.min(10, h*0.6);
    ctx.fillStyle = 'linear-gradient'; // we'll draw solid dark
    ctx.fillStyle = '#111';
    ctx.beginPath(); ctx.roundRect(x-h, y-h, L, L, r); ctx.fill();
    ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.lineWidth=2; ctx.stroke();
    ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font = 'bold '+Math.floor(h*1.3)+'px system-ui';
    ctx.fillText(kind==='minus' ? 'âˆ’' : 'Ã·', x, y+1);
  }

  function roundRectPath(x,y,w,h,r){
    ctx.beginPath(); ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
  }

  // ===== loop =====
  function toast(msg){ toastEl.textContent=msg; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'), 1300); }
  let acc=0, last=performance.now();
  function loop(now){
    const dt = (now-last)/1000; last=now; acc += dt;
    while(acc>DT){ step(DT); acc-=DT; }
    draw(); requestAnimationFrame(loop);
  }
  reset(); updateHUD(); requestAnimationFrame(loop);
})();
</script>

<!-- Service Workerï¼ˆã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾å¿œãƒ»å‹•çš„ç”Ÿæˆï¼‰ -->
<script>
if ('serviceWorker' in navigator) {
  const code = `
    const CACHE='10game-decamerge-v34-sqops';
    self.addEventListener('install',e=>{
      e.waitUntil(caches.open(CACHE).then(c=>c.addAll(['./'])));
      self.skipWaiting();
    });
    self.addEventListener('activate',e=>{
      e.waitUntil(caches.keys().then(keys=>Promise.all(keys.map(k=>k!==CACHE&&caches.delete(k)))));
      self.clients.claim();
    });
    self.addEventListener('fetch',e=>{
      e.respondWith(caches.match(e.request).then(r=>r||fetch(e.request)));
    });
  `;
  const blob = new Blob([code], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);
  addEventListener('load', () => navigator.serviceWorker.register(url));
}
</script>
</body>
</html>
