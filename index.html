<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<title>10 Game — DecaMerge v2.3</title>
<meta name="theme-color" content="#F6F3EE">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAukB9Wj1nZkAAAAASUVORK5CYII=">

<!-- Manifest (inline) -->
<script type="application/manifest+json">
{
  "name": "10 Game — DecaMerge",
  "short_name": "10 Game",
  "start_url": ".",
  "display": "standalone",
  "background_color": "#F6F3EE",
  "theme_color": "#F6F3EE",
  "icons": [
    {"src":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAukB9Wj1nZkAAAAASUVORK5CYII=","sizes":"192x192","type":"image/png"}
  ]
}
</script>

<style>
  :root{
    --bg:#F6F3EE; --paper:#FFFFFF; --ink:#1B1B1B; --muted:#6D7280; --line:#E6E0D7; --chip:#FAF8F4;
    --accent:#E24E52; --ok:#12B886;
    --n1:#E96B6B; --n2:#F0A27A; --n3:#F3D277; --n4:#90CDBF; --n5:#BDE0FE;
    --n6:#7CB7F3; --n7:#B7A4E8; --n8:#F48BC6; --n9:#D3AE63;
    --b10:#3BB273; --b20:#2A8FBD; --b40:#8266CC; --b80:#E05C80; --b160:#D9922B;
  }
  *{box-sizing:border-box}
  html,body{
    height:100%; margin:0; color:var(--ink);
    background:radial-gradient(1200px 600px at 50% -10%,#FFF,#F6F3EE 55%);
    font-family:-apple-system,BlinkMacSystemFont,"SF Pro Display","Helvetica Neue","Segoe UI",Roboto,"Noto Sans JP",Arial,sans-serif;
  }
  #wrap{min-height:100%;display:flex;flex-direction:column}

  header{padding:10px 14px;display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;border-bottom:1px solid var(--line)}
  .brand{display:flex;align-items:baseline;gap:10px}
  .ttl{font-weight:800;letter-spacing:.02em}
  .sub{color:var(--muted);font-size:12px;letter-spacing:.04em}
  .chips{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  .chip{background:var(--chip);border:1px solid var(--line);padding:8px 10px;border-radius:12px}
  .btn{border:1px solid var(--line);padding:8px 12px;border-radius:12px;background:#fff;font-weight:700}
  .btn.strong{border-color:transparent;background:#111;color:#fff}
  .btn.ghost{background:#fff}
  .btn:disabled{opacity:.45}
  .nextBadge{display:flex;align-items:center;gap:8px;background:var(--accent);color:#fff;border-radius:14px;padding:8px 12px;font-weight:800}
  .nextCircle{width:36px;height:36px;border-radius:50%;background:rgba(255,255,255,.22);display:grid;place-items:center;font-size:18px}
  .pair{opacity:.85;font-size:12px}

  #stage{flex:1;display:flex;align-items:center;justify-content:center;padding:14px}
  canvas{touch-action:none;background:var(--paper);border:1px solid var(--line);border-radius:16px;box-shadow:0 8px 40px rgba(0,0,0,.06)}

  footer{padding:10px 14px;border-top:1px solid var(--line);color:var(--muted);font-size:14px;text-align:center}

  .toast{position:fixed;left:50%;bottom:20px;transform:translateX(-50%);
    background:#111;color:#fff;border-radius:10px;padding:10px 14px;opacity:0;transition:.25s}
  .toast.show{opacity:1}

  /* Help modal */
  #help{position:fixed;inset:0;background:rgba(0,0,0,.38);display:none;align-items:center;justify-content:center;padding:18px}
  #help[open]{display:flex}
  #help .card{width:min(560px,92vw);background:#fff;border:1px solid var(--line);border-radius:16px;padding:16px}
  #help h3{margin:.2em 0 .6em;font-size:18px}
  #help ol{padding-left:1.1em;line-height:1.6}
  #help li{margin:.35em 0}
  #help .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="brand">
      <div class="ttl">10 Game</div>
      <div class="sub">DecaMerge — 足して10 → 10→20→40…</div>
    </div>
    <div class="chips">
      <div class="chip">Score: <b id="score">0</b> / Best: <b id="best">0</b></div>
      <div class="nextBadge">
        Next
        <div class="nextCircle" id="nextCircleA">-</div>
        <div class="nextCircle" id="nextCircleB">-</div>
        <span class="pair">→ 補数 <b id="pairNum">-</b></span>
      </div>
      <button class="btn ghost" id="helpBtn" aria-haspopup="dialog" aria-controls="help">遊び方</button>
      <button class="btn ghost" id="hintBtn">ヒント ON</button>
      <button class="btn ghost" id="undoBtn" disabled>元に戻す</button>
      <button class="btn strong" id="resetBtn">リセット</button>
    </div>
  </header>

  <div id="stage">
    <canvas id="cv" width="360" height="640" aria-label="10 Game canvas"></canvas>
  </div>

  <footer>
    指で<strong>左右にスライド</strong>→<strong>指を離す</strong>と投入。<br>
    <b>小玉</b>は接して合計<b>10</b>（ペア優先 → 3個 → 4個）で<strong>即合体</strong>。<b>同じ大玉</b>は<b>倍々合体</b>！
  </footer>
</div>

<!-- How-to -->
<div id="help" role="dialog" aria-modal="true" aria-label="遊び方">
  <div class="card">
    <h3>🎮 遊び方（10 Game - DecaMerge）</h3>
    <ol>
      <li>画面上で指を<strong>左右にスライド</strong>して狙いを合わせます。</li>
      <li><strong>指を離す</strong>と、その位置に玉が落ちます（スライド中は落ちません）。</li>
      <li><strong>1〜9の小玉</strong>は、触れ合ってできるグループの中で合計が<strong>10</strong>になる組合せがあれば<strong>即「10」玉に合体</strong>します（ペア優先）。</li>
      <li><strong>10,20,40…の大玉</strong>は<strong>同じ値どうしが触れる</strong>と合体して<strong>倍</strong>になります。</li>
      <li>上の赤線より上に玉が居続けると<b>ゲームオーバー</b>。<b>元に戻す</b>で1手やり直し可能。</li>
    </ol>
    <p style="color:var(--muted);font-size:13px">ヒントONで各小玉に「10まであといくつ」を表示。</p>
    <div class="actions">
      <button class="btn ghost" id="closeHelp">閉じる</button>
      <button class="btn strong" id="okHelp">OK</button>
    </div>
  </div>
</div>

<div id="toast" class="toast"></div>

<script>
(()=> {
  // ===== DOM =====
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const nextAEl = document.getElementById('nextCircleA');
  const nextBEl = document.getElementById('nextCircleB');
  const pairNumEl = document.getElementById('pairNum');
  const resetBtn = document.getElementById('resetBtn');
  const hintBtn = document.getElementById('hintBtn');
  const undoBtn = document.getElementById('undoBtn');
  const toastEl = document.getElementById('toast');
  const helpBtn = document.getElementById('helpBtn');
  const helpModal = document.getElementById('help');
  const closeHelp = document.getElementById('closeHelp');
  const okHelp = document.getElementById('okHelp');

  // ===== layout fit =====
  function fit(){
    const maxW = Math.min(innerWidth - 24, 440);
    const ratio = maxW / cv.width;
    cv.style.width = maxW+'px';
    cv.style.height = (cv.height*ratio)+'px';
  }
  addEventListener('resize', fit); fit();

  // ===== physics tuned (難易度↑ 少しだけ) =====
  const W = cv.width, H = cv.height;
  const LEFT = 22, RIGHT = W-22, FLOOR = H-14, CEIL = 80; // 赤線y=CEIL
  const G = 1550;        // 1280 → 1550
  const DT = 1/60;
  const AIR_FRICTION = 0.988;   // 0.992 → 0.988（少し滑る）
  const REST_FLOOR = 0.15;      // 反発係数（正しい定義で実装）
  const REST_WALL  = 0.12;
  const IMPULSE_DAMP = 0.22;    // 衝突時の相対速度削減
  const MAX_BALLS = 90;
  const VX_MAX = 950, VY_MAX = 2400;

  // ===== state =====
  /** @type {{x:number,y:number,vx:number,vy:number,r:number,val:number,id:number}[]} */
  let balls = [], rings = [];
  let score = 0, over = false, cooldown = 0;
  let aimX = (LEFT+RIGHT)/2;
  let nextQ = [randSmall(), randSmall()]; // Next2
  let showHint = true;
  let dangerTime = 0;
  let idSeq = 1;

  // gesture / modal
  let helpOpen = false, dragging = false, activePointer=null;

  // undo
  let undoState = null;

  // ===== helpers =====
  const CSS = (n)=>getComputedStyle(document.documentElement).getPropertyValue(n).trim();
  const smallColor = (v)=>CSS('--n'+v);
  function bigColor(v){
    if (v>=160) return CSS('--b160');
    if (v>=80)  return CSS('--b80');
    if (v>=40)  return CSS('--b40');
    if (v>=20)  return CSS('--b20');
    return CSS('--b10');
  }
  function radiusFor(v){
    if (v<10) return 16 + v*1.9;
    const raw = 22 + Math.log2(v/10 + 1) * 21;
    return Math.min(raw, 58);
  }
  function randSmall(){
    const r = Math.random();
    if (r<0.15) return 1; if (r<0.30) return 2; if (r<0.47) return 3; if (r<0.64) return 4;
    if (r<0.78) return 5; if (r<0.88) return 6; if (r<0.94) return 7; if (r<0.98) return 8; return 9;
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function updateHUD(){
    scoreEl.textContent = score|0;
    const best = +(localStorage.getItem('decamerge_best')||0);
    if (score>best) localStorage.setItem('decamerge_best', score|0);
    bestEl.textContent = localStorage.getItem('decamerge_best')||0;
    nextAEl.textContent = nextQ[0];
    nextBEl.textContent = nextQ[1];
    pairNumEl.textContent = 10-nextQ[0];
    hintBtn.textContent = showHint ? 'ヒント OFF' : 'ヒント ON';
    undoBtn.disabled = !undoState;
  }

  // ===== modal open/close =====
  function resetPointerState(){
    try { if (activePointer!==null) cv.releasePointerCapture(activePointer); } catch(e){}
    dragging=false; activePointer=null;
  }
  function openHelp(){ helpOpen=true; helpModal.setAttribute('open',''); resetPointerState(); }
  function closeHelpModal(){ helpOpen=false; helpModal.removeAttribute('open'); resetPointerState(); }
  helpBtn.addEventListener('click', openHelp);
  closeHelp.addEventListener('click', closeHelpModal);
  okHelp.addEventListener('click', closeHelpModal);
  helpModal.addEventListener('click', (e)=>{ if (e.target===helpModal) closeHelpModal(); });
  addEventListener('keydown', (e)=>{ if (e.key==='Escape' && helpOpen) closeHelpModal(); });
  if (!localStorage.getItem('decamerge_seen_help')) { openHelp(); localStorage.setItem('decamerge_seen_help','1'); }

  // ===== pointer inputs =====
  function canvasX(e){
    const rect = cv.getBoundingClientRect();
    const clientX = e.clientX ?? (e.touches && e.touches[0].clientX) ?? rect.left;
    return (clientX - rect.left) * (cv.width/rect.width);
  }
  function onPointerDown(e){
    if (helpOpen) return;
    if (activePointer !== null) return;
    cv.setPointerCapture(e.pointerId);
    activePointer = e.pointerId;
    dragging = true;
    aimX = clamp(canvasX(e), LEFT, RIGHT);
  }
  function onPointerMove(e){
    if (!dragging || e.pointerId !== activePointer) return;
    aimX = clamp(canvasX(e), LEFT, RIGHT);
  }
  function onPointerUp(e){
    if (e.pointerId !== activePointer) return;
    if (!helpOpen) drop(); // 指を離したら必ず落とす
    resetPointerState();
  }
  if (window.PointerEvent){
    cv.addEventListener('pointerdown', onPointerDown, {passive:false});
    cv.addEventListener('pointermove', onPointerMove, {passive:false});
    cv.addEventListener('pointerup',   onPointerUp,   {passive:false});
    cv.addEventListener('pointercancel', ()=> resetPointerState(), {passive:true});
  }

  resetBtn.addEventListener('click', reset);
  hintBtn.addEventListener('click', ()=>{ showHint = !showHint; updateHUD(); });
  undoBtn.addEventListener('click', undo);

  // ===== game control =====
  function reset(){
    balls = []; rings = []; score=0; over=false; cooldown=0; dangerTime=0;
    aimX=(LEFT+RIGHT)/2; nextQ=[randSmall(), randSmall()]; undoState=null;
    updateHUD();
  }
  function snapshot(){
    return { balls: balls.map(b=>({x:b.x,y:b.y,vx:b.vx,vy:b.vy,r:b.r,val:b.val,id:b.id})),
             rings: rings.map(r=>({...r})),
             score, over, cooldown, dangerTime, aimX, nextQ:[...nextQ] };
  }
  function restore(s){
    balls = s.balls.map(b=>({...b}));
    rings = s.rings.map(r=>({...r}));
    score = s.score; over=s.over; cooldown=s.cooldown; dangerTime=s.dangerTime; aimX=s.aimX; nextQ=[...s.nextQ];
    updateHUD();
  }
  function undo(){
    if (!undoState) return;
    restore(undoState); undoState=null; toast('1手戻しました');
  }
  function drop(){
    if (over || cooldown>0) return;
    if (balls.length>=MAX_BALLS){ toast('いっぱいです。合体で減らそう！'); return; }
    undoState = snapshot();
    const val = nextQ.shift(); nextQ.push(randSmall());
    const r = radiusFor(val);
    const x = clamp(aimX, LEFT+r+1, RIGHT-r-1);
    balls.push({x, y: CEIL-30, vx:0, vy:0, r, val, id:idSeq++});
    score += val; cooldown = .18; updateHUD();
  }

  // ===== physics =====
  function step(dt){
    cooldown = Math.max(0, cooldown-dt);
    for (const b of balls){
      b.vy += G*dt;
      b.vx *= AIR_FRICTION; b.vy *= AIR_FRICTION;
      b.vx = clamp(b.vx, -VX_MAX, VX_MAX);
      b.vy = clamp(b.vy, -VY_MAX, VY_MAX);
      b.x  += b.vx*dt;  b.y  += b.vy*dt;

      // 壁
      if (b.x - b.r < LEFT){ b.x = LEFT + b.r; b.vx = -Math.abs(b.vx)*REST_WALL; }
      if (b.x + b.r > RIGHT){ b.x = RIGHT - b.r; b.vx =  Math.abs(b.vx)*(-REST_WALL); }

      // 床
      if (b.y + b.r > FLOOR){
        b.y = FLOOR - b.r;
        if (Math.abs(b.vy) < 45) b.vy = 0; else b.vy = -b.vy * REST_FLOOR;
        if (b.vy === 0){ b.vx *= 0.965; if (Math.abs(b.vx)<6) b.vx = 0; }
      }
    }

    // 衝突（非弾性寄り）
    for (let i=0;i<balls.length;i++){
      for (let j=i+1;j<balls.length;j++){
        const A=balls[i], B=balls[j];
        const dx=B.x-A.x, dy=B.y-A.y, dist=Math.hypot(dx,dy), minD=A.r+B.r;
        if (dist>0 && dist<minD){
          const nx=dx/dist, ny=dy/dist, overlap=minD-dist;
          A.x-=nx*overlap*0.5; A.y-=ny*overlap*0.5;
          B.x+=nx*overlap*0.5; B.y+=ny*overlap*0.5;
          const rvx=B.vx-A.vx, rvy=B.vy-A.vy, vn=rvx*nx+rvy*ny, imp=-vn*IMPULSE_DAMP;
          A.vx-=imp*nx; A.vy-=imp*ny; B.vx+=imp*nx; B.vy+=imp*ny;
        }
      }
    }

    // 合体（厳しめ接触）……複数パスで収束
    let merged, pass=0;
    do{ merged = tryMergesTighter(); pass++; } while(merged && pass<10);

    // エフェクト
    for (const r of rings){ r.t += dt; }
    rings = rings.filter(r=>r.t<0.9);

    // 赤線より上に少しでも接触していた累計時間で判定（猶予 1.0s）
    if (balls.some(b=>b.y - b.r < CEIL)) dangerTime += dt; else dangerTime = 0;
    if (dangerTime > 1.0 && !over){ over = true; toast('GAME OVER! 元に戻す or リセット'); }
  }

  // ===== merging（接触を締める + ペア優先） =====
  const MERGE_OVERLAP = 1; // px: 「重なり必須」＝ rA+rB から 1px 以上内側
  function overlapping(a,b){
    const dx=b.x-a.x, dy=b.y-a.y, dist=Math.hypot(dx,dy);
    return dist <= (a.r + b.r - MERGE_OVERLAP);
  }

  function tryMergesTighter(){
    let changed = false;

    // 1) 大玉：同値が重なったら倍化
    const removedEq = new Set();
    for (let i=0;i<balls.length;i++){
      const A=balls[i]; if (removedEq.has(A.id) || A.val<10) continue;
      for (let j=i+1;j<balls.length;j++){
        const B=balls[j]; if (removedEq.has(B.id) || B.val<10) continue;
        if (A.val===B.val && overlapping(A,B)){
          const nx=(A.x+B.x)/2, ny=(A.y+B.y)/2, out=A.val*2;
          balls.push({x:nx,y:ny,vx:(A.vx+B.vx)*0.1,vy:(A.vy+B.vy)*0.1,r:radiusFor(out),val:out,id:idSeq++});
          removedEq.add(A.id); removedEq.add(B.id);
          rings.push({x:nx,y:ny,t:0,col:bigColor(out)});
          score += Math.max(30,out); changed=true; break;
        }
      }
    }
    if (removedEq.size){ balls = balls.filter(b=>!removedEq.has(b.id)); updateHUD(); }

    // 2) 小玉：接触グラフ → 連結成分ごとに subset-sum=10 を探索（2個→3個→4個の順）
    const small = balls.filter(b=>b.val<10);
    if (small.length){
      const idx = new Map(); small.forEach((b,i)=>idx.set(b.id,i));
      const adj = small.map(()=>[]);
      for (let i=0;i<small.length;i++)
        for (let j=i+1;j<small.length;j++)
          if (overlapping(small[i], small[j])){ adj[i].push(j); adj[j].push(i); }

      const visited = new Array(small.length).fill(false);
      const toRemove = new Set();
      const toAdd = [];

      for (let s=0;s<small.length;s++){
        if (visited[s]) continue;
        // 成分抽出
        const comp=[]; const q=[s]; visited[s]=true;
        while(q.length){ const v=q.shift(); comp.push(v); for (const nb of adj[v]) if(!visited[nb]){visited[nb]=true;q.push(nb);} }
        if (comp.length<2) continue;

        const vals = comp.map(i=>small[i].val);
        const refs = comp.map(i=>small[i]);

        // 段階的に探索：2個→3個→4個（難易度UP：大量消しはしない）
        const orders = [2,3,4];
        let found = false;

        for (const kSize of orders){
          if (found) break;
          // 早期カット：最大でも成分サイズが足りなければ次へ
          if (comp.length < kSize) continue;

          // 組合せ探索（k-combination）
          // 値の大きい順で早めにヒットさせる（2+8, 4+6 など）
          const ordIdx = [...refs.keys()].sort((a,b)=>refs[b].val-refs[a].val);

          function kComb(start, choose, picked, sum){
            if (found) return;
            if (picked.length===choose){
              if (sum===10){
                // 合体実行
                const chosenBalls = picked.map(i=>refs[i]);
                const cx = chosenBalls.reduce((a,b)=>a+b.x,0)/chosenBalls.length;
                const cy = chosenBalls.reduce((a,b)=>a+b.y,0)/chosenBalls.length;
                const cvx= chosenBalls.reduce((a,b)=>a+b.vx,0)/chosenBalls.length * 0.1;
                const cvy= chosenBalls.reduce((a,b)=>a+b.vy,0)/chosenBalls.length * 0.1;
                toAdd.push({x:cx,y:cy,vx:cvx,vy:cvy,r:radiusFor(10),val:10,id:idSeq++});
                chosenBalls.forEach(b=>toRemove.add(b.id));
                rings.push({x:cx,y:cy,t:0,col:bigColor(10)});
                score += 20 + 2*picked.length; // 少し抑えた得点
                found = true;
              }
              return;
            }
            for (let i=start;i<ordIdx.length;i++){
              const idxInComp = ordIdx[i];
              kComb(i+1, choose, [...picked, idxInComp], sum + refs[idxInComp].val);
              if (found) return;
            }
          }
          kComb(0, kSize, [], 0);
        }

        // 反映
        if (toRemove.size){
          balls = balls.filter(b=>!toRemove.has(b.id));
          balls.push(...toAdd);
          updateHUD();
        }
      }
    }

    return changed || false;
  }

  // ===== draw =====
  function draw(){
    ctx.clearRect(0,0,W,H);
    // 枠
    ctx.strokeStyle = CSS('--line'); ctx.lineWidth = 2;
    roundRectPath(LEFT-8, 6, RIGHT-LEFT+16, FLOOR-6, 16); ctx.stroke();
    // 赤線（ゲームオーバー基準）
    ctx.strokeStyle = 'rgba(226,78,82,.6)'; ctx.beginPath(); ctx.moveTo(LEFT, CEIL); ctx.lineTo(RIGHT, CEIL); ctx.stroke();

    // ゴースト：次の玉
    const rN = radiusFor(nextQ[0]);
    const ax = clamp(aimX, LEFT+rN+1, RIGHT-rN-1);
    ctx.globalAlpha = .28; drawBall(ax, CEIL-30, rN, nextQ[0]); ctx.globalAlpha = 1;

    // 玉
    for (const b of balls){ drawBall(b.x,b.y,b.r,b.val); }

    // 合体リング
    for (const rr of rings){
      ctx.globalAlpha = Math.max(0, 1 - rr.t*1.1);
      ctx.strokeStyle = rr.col; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(rr.x, rr.y, 8 + rr.t*42, 0, Math.PI*2); ctx.stroke();
      ctx.globalAlpha = 1;
    }

    if (over){
      ctx.fillStyle = 'rgba(0,0,0,.48)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.font='bold 32px system-ui'; ctx.fillText('GAME OVER', W/2, H*0.42);
      ctx.font='16px system-ui'; ctx.fillText('「元に戻す」または「リセット」', W/2, H*0.58);
    }
  }

  function drawBall(x,y,r,val){
    const base = val<10 ? smallColor(val) : bigColor(val);
    const g = ctx.createRadialGradient(x-r*0.45,y-r*0.45,r*0.28, x,y,r);
    g.addColorStop(0,'#fff'); g.addColorStop(1, base);
    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='rgba(0,0,0,.08)'; ctx.lineWidth=2; ctx.stroke();
    ctx.fillStyle='#111'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font = 'bold '+Math.floor(r*0.9)+'px system-ui'; ctx.fillText(val, x, y+1);
    if (showHint && val<10){
      ctx.fillStyle='rgba(0,0,0,.35)'; ctx.font=Math.floor(r*0.42)+'px system-ui';
      ctx.fillText(10-val, x, y - r*0.95);
    }
  }
  function roundRectPath(x,y,w,h,r){
    ctx.beginPath(); ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
  }

  // ===== toast & loop =====
  function toast(msg){ toastEl.textContent=msg; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'), 1300); }
  let acc=0, last=performance.now();
  function loop(now){
    const dt = (now-last)/1000; last=now; acc += dt;
    while(acc>DT){ step(DT); acc-=DT; }
    draw(); requestAnimationFrame(loop);
  }
  reset(); updateHUD(); requestAnimationFrame(loop);
})();
</script>

<!-- Service Worker（オフライン対応・動的生成） -->
<script>
if ('serviceWorker' in navigator) {
  const code = `
    const CACHE='10game-decamerge-v23';
    self.addEventListener('install',e=>{
      e.waitUntil(caches.open(CACHE).then(c=>c.addAll(['./'])));
      self.skipWaiting();
    });
    self.addEventListener('activate',e=>{
      e.waitUntil(caches.keys().then(keys=>Promise.all(keys.map(k=>k!==CACHE&&caches.delete(k)))));
      self.clients.claim();
    });
    self.addEventListener('fetch',e=>{
      e.respondWith(caches.match(e.request).then(r=>r||fetch(e.request)));
    });
  `;
  const blob = new Blob([code], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);
  addEventListener('load', () => navigator.serviceWorker.register(url));
}
</script>
</body>
</html>
